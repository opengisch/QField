
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.3">
    
    
      
        <title>File qgsquickmapcanvasmap.cpp - QField API Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#file-qgsquickmapcanvasmapcpp" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="QField API Documentation" class="md-header__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            QField API Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              File qgsquickmapcanvasmap.cpp
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.768 3.96zl-.002-.005a9 9 0 0 0-.218-.779c-.13-.394.21-.8.602-.67q.435.144.855.328l.01.005A10.002 10.002 0 0 1 12 22a10 10 0 0 1-9.162-5.985l-.004-.01a10 10 0 0 1-.329-.855c-.13-.392.277-.732.67-.602q.386.126.78.218l.004.002A9 9 0 0 0 14.999 6a9 9 0 0 0-.231-2.04M16.5 6c0 5.799-4.701 10.5-10.5 10.5q-.64 0-1.26-.075A8.5 8.5 0 1 0 16.425 4.74q.075.62.075 1.259Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 19a7 7 0 1 1 0-14 7 7 0 0 1 0 14m0-1.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 1 0 0 11m-5.657.157a.75.75 0 0 1 0 1.06l-1.768 1.768a.749.749 0 0 1-1.275-.326.75.75 0 0 1 .215-.734l1.767-1.768a.75.75 0 0 1 1.061 0M3.515 3.515a.75.75 0 0 1 1.06 0l1.768 1.768a.749.749 0 0 1-.326 1.275.75.75 0 0 1-.734-.215L3.515 4.575a.75.75 0 0 1 0-1.06M12 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 12 0M4 12a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 12m8 8a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 12 20m12-8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 24 12m-6.343 5.657a.75.75 0 0 1 1.06 0l1.768 1.768a.75.75 0 0 1-.018 1.042.75.75 0 0 1-1.042.018l-1.768-1.767a.75.75 0 0 1 0-1.061m2.828-14.142a.75.75 0 0 1 0 1.06l-1.768 1.768a.75.75 0 0 1-1.042-.018.75.75 0 0 1-.018-1.042l1.767-1.768a.75.75 0 0 1 1.061 0"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="QField API Documentation" class="md-nav__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    QField API Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../snippets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Code Snippets
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__core/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    C++ Classes
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__qml/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    QML Items
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="file-qgsquickmapcanvasmapcpp">File qgsquickmapcanvasmap.cpp</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_aebb8dcc11953d78e620bbef0b9e2183/"><strong>core</strong></a> <strong>&gt;</strong> <a href="../dir_19c3d7c8ba6dc95926fecc96295d1560/"><strong>qgsquick</strong></a> <strong>&gt;</strong> <a href="../qgsquickmapcanvasmap_8cpp/"><strong>qgsquickmapcanvasmap.cpp</strong></a></p>
<p><a href="../qgsquickmapcanvasmap_8cpp/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/***************************************************************************
  qgsquickmapcanvasmap.cpp
  --------------------------------------
  Date                 : 10.12.2014
  Copyright            : (C) 2014 by Matthias Kuhn
  Email                : matthias (at) opengis.ch
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include &quot;qgsquickmapcanvasmap.h&quot;
#include &quot;qgsquickmapsettings.h&quot;

#include &lt;QQuickWindow&gt;
#include &lt;QSGSimpleTextureNode&gt;
#include &lt;QScreen&gt;
#include &lt;qgis.h&gt;
#include &lt;qgsannotationlayer.h&gt;
#include &lt;qgsexpressioncontextutils.h&gt;
#include &lt;qgsgrouplayer.h&gt;
#include &lt;qgslabelingresults.h&gt;
#include &lt;qgsmaplayerelevationproperties.h&gt;
#include &lt;qgsmaplayertemporalproperties.h&gt;
#include &lt;qgsmaprenderercache.h&gt;
#include &lt;qgsmaprendererparalleljob.h&gt;
#include &lt;qgsmaprenderersequentialjob.h&gt;
#include &lt;qgsmessagelog.h&gt;
#include &lt;qgspallabeling.h&gt;
#include &lt;qgsproject.h&gt;
#include &lt;qgssymbollayerutils.h&gt;
#include &lt;qgsvectorlayer.h&gt;


QgsQuickMapCanvasMap::QgsQuickMapCanvasMap( QQuickItem *parent )
  : QQuickItem( parent )
  , mMapSettings( std::make_unique&lt;QgsQuickMapSettings&gt;() )
  , mCache( std::make_unique&lt;QgsMapRendererCache&gt;() )
{
  connect( this, &amp;QQuickItem::windowChanged, this, &amp;QgsQuickMapCanvasMap::onWindowChanged );
  connect( &amp;mRefreshTimer, &amp;QTimer::timeout, this, [this] { refreshMap(); } );
  connect( &amp;mMapUpdateTimer, &amp;QTimer::timeout, this, &amp;QgsQuickMapCanvasMap::renderJobUpdated );

  connect( mMapSettings.get(), &amp;QgsQuickMapSettings::extentChanged, this, &amp;QgsQuickMapCanvasMap::onExtentChanged );
  connect( mMapSettings.get(), &amp;QgsQuickMapSettings::rotationChanged, this, &amp;QgsQuickMapCanvasMap::onRotationChanged );
  connect( mMapSettings.get(), &amp;QgsQuickMapSettings::layersChanged, this, &amp;QgsQuickMapCanvasMap::onLayersChanged );
  connect( mMapSettings.get(), &amp;QgsQuickMapSettings::temporalStateChanged, this, &amp;QgsQuickMapCanvasMap::onTemporalStateChanged );
  connect( mMapSettings.get(), &amp;QgsQuickMapSettings::zRangeChanged, this, &amp;QgsQuickMapCanvasMap::onZRangeChanged );

  connect( this, &amp;QgsQuickMapCanvasMap::renderStarting, this, &amp;QgsQuickMapCanvasMap::isRenderingChanged );
  connect( this, &amp;QgsQuickMapCanvasMap::mapCanvasRefreshed, this, &amp;QgsQuickMapCanvasMap::isRenderingChanged );

  mMapUpdateTimer.setSingleShot( false );
  mMapUpdateTimer.setInterval( 250 );
  mRefreshTimer.setSingleShot( true );
  setTransformOrigin( QQuickItem::Center );
  setFlags( QQuickItem::ItemHasContents );
}

QgsQuickMapCanvasMap::~QgsQuickMapCanvasMap()
{
  stopRendering();
}

QgsQuickMapSettings *QgsQuickMapCanvasMap::mapSettings() const
{
  return mMapSettings.get();
}

void QgsQuickMapCanvasMap::rotate( double degrees )
{
  mMapSettings-&gt;setRotation( mMapSettings-&gt;rotation() + degrees );
}

void QgsQuickMapCanvasMap::zoomByFactor( const QPointF center, qreal factor, bool handleMargins )
{
  QgsRectangle extent = mMapSettings-&gt;extent();
  QgsPoint oldCenter( extent.center() );
  QgsPoint mousePos( mMapSettings-&gt;screenToCoordinate( center ) );

  QgsPointXY newCenter( mousePos.x() + ( ( oldCenter.x() - mousePos.x() ) * factor ),
                        mousePos.y() + ( ( oldCenter.y() - mousePos.y() ) * factor ) );

  // same as zoomWithCenter (no coordinate transformations are needed)
  extent.scale( factor, &amp;newCenter );
  mMapSettings-&gt;setExtent( extent, handleMargins );
}

void QgsQuickMapCanvasMap::zoomScale( const QPointF center, qreal scale, bool handleMargins )
{
  QgsRectangle extent = mMapSettings-&gt;extent();
  const double oldScale = mMapSettings-&gt;computeScaleForExtent( extent, handleMargins );
  const QgsPoint oldCenter( extent.center() );

  extent += QgsVector( center.x() - oldCenter.x(), center.y() - oldCenter.y() );
  extent.scale( scale / oldScale );

  mMapSettings-&gt;setExtent( extent, handleMargins );
}

void QgsQuickMapCanvasMap::pan( const QPointF oldPos, const QPointF newPos )
{
  QgsPoint start = mMapSettings-&gt;screenToCoordinate( oldPos.toPoint() );
  QgsPoint end = mMapSettings-&gt;screenToCoordinate( newPos.toPoint() );

  double dx = end.x() - start.x();
  double dy = end.y() - start.y();

  // modify the extent
  QgsRectangle extent = mMapSettings-&gt;extent();

  extent.setXMinimum( extent.xMinimum() + dx );
  extent.setXMaximum( extent.xMaximum() + dx );
  extent.setYMaximum( extent.yMaximum() + dy );
  extent.setYMinimum( extent.yMinimum() + dy );

  mMapSettings-&gt;setExtent( extent );
}

void QgsQuickMapCanvasMap::refreshMap()
{
  stopRendering(); // if any...

  QgsMapSettings mapSettings = mMapSettings-&gt;mapSettings();
  if ( !mapSettings.hasValidSettings() )
    return;

  if ( !qgsDoubleNear( mQuality, 1.0 ) )
  {
    mapSettings.setOutputSize( mapSettings.outputSize() * mQuality );
    mapSettings.setOutputDpi( mapSettings.outputDpi() * mQuality );
  }

  //build the expression context
  QgsExpressionContext expressionContext;
  expressionContext &lt;&lt; QgsExpressionContextUtils::globalScope()
                    &lt;&lt; QgsExpressionContextUtils::mapSettingsScope( mapSettings );

  QgsProject *project = mMapSettings-&gt;project();
  if ( project )
  {
    expressionContext &lt;&lt; QgsExpressionContextUtils::projectScope( project );

    mapSettings.setLabelingEngineSettings( project-&gt;labelingEngineSettings() );

    // render main annotation layer above all other layers
    QList&lt;QgsMapLayer *&gt; allLayers = mapSettings.layers();
    allLayers.insert( 0, project-&gt;mainAnnotationLayer() );
    mapSettings.setLayers( allLayers );
  }

  mapSettings.setExpressionContext( expressionContext );

  // enables on-the-fly simplification of geometries to spend less time rendering
  mapSettings.setFlag( Qgis::MapSettingsFlag::UseRenderingOptimization );
  // with incremental rendering - enables updates of partially rendered layers (good for WMTS, XYZ layers)
  mapSettings.setFlag( Qgis::MapSettingsFlag::RenderPartialOutput, mIncrementalRendering );
  // pick a better image format across all platforms
  mapSettings.setOutputImageFormat( QImage::Format_RGBA8888_Premultiplied );

  // create the renderer job
  Q_ASSERT( !mJob );
  mJob = new QgsMapRendererParallelJob( mapSettings );

  if ( mIncrementalRendering )
    mMapUpdateTimer.start();

  connect( mJob, &amp;QgsMapRendererJob::renderingLayersFinished, this, &amp;QgsQuickMapCanvasMap::renderJobUpdated );
  connect( mJob, &amp;QgsMapRendererJob::finished, this, &amp;QgsQuickMapCanvasMap::renderJobFinished );
  mJob-&gt;setCache( mCache.get() );
  mJob-&gt;setLayerRenderingTimeHints( mLastLayerRenderTime );

  mJob-&gt;start();

  if ( !mSilentRefresh )
  {
    emit renderStarting();
  }
}

void QgsQuickMapCanvasMap::renderJobUpdated()
{
  if ( !mJob )
    return;

  mImage = mJob-&gt;renderedImage();
  mImageMapSettings = mJob-&gt;mapSettings();
  mPreviewImages.clear();
  mDirty = true;
  // Temporarily freeze the canvas, we only need to reset the geometry but not trigger a repaint
  bool freeze = mFreeze;
  mFreeze = true;
  updateTransform( true );
  mFreeze = freeze;

  update();
}

void QgsQuickMapCanvasMap::renderJobFinished()
{
  if ( !mJob )
    return;

  const QgsMapRendererJob::Errors errors = mJob-&gt;errors();
  for ( const QgsMapRendererJob::Error &amp;error : errors )
  {
    QgsMessageLog::logMessage( QStringLiteral( &quot;%1 :: %2&quot; ).arg( error.layerID, error.message ), tr( &quot;Rendering&quot; ) );
  }

  // take labeling results before emitting renderComplete, so labeling map tools
  // connected to signal work with correct results
  delete mLabelingResults;
  mLabelingResults = mJob-&gt;takeLabelingResults();

  mImage = mJob-&gt;renderedImage();
  mImageMapSettings = mJob-&gt;mapSettings();
  mPreviewImages.clear();

  // now we are in a slot called from mJob - do not delete it immediately
  // so the class is still valid when the execution returns to the class
  mJob-&gt;deleteLater();
  mJob = nullptr;
  mDirty = true;
  mMapUpdateTimer.stop();

  // Temporarily freeze the canvas, we only need to reset the geometry but not trigger a repaint
  bool freeze = mFreeze;
  mFreeze = true;
  updateTransform( true );
  mFreeze = freeze;

  update();
  if ( !mSilentRefresh )
  {
    emit mapCanvasRefreshed();
  }
  else
  {
    mSilentRefresh = false;
  }

  if ( mDeferredRefreshPending )
  {
    mDeferredRefreshPending = false;
    mSilentRefresh = true;
    refresh( true );
  }
  else if ( mPreviewJobsEnabled )
  {
    startPreviewJobs();
  }
}

void QgsQuickMapCanvasMap::layerRepaintRequested( bool deferred )
{
  if ( mMapSettings-&gt;outputSize().isNull() )
    return; // the map image size has not been set yet

  if ( deferred || mForceDeferredLayersRepaint || mFreeze )
  {
    if ( !mJob &amp;&amp; !mRefreshTimer.isActive() )
    {
      mSilentRefresh = true;
      refresh( true );
    }
    else
    {
      mDeferredRefreshPending = true;
    }
  }
  else
  {
    refresh();
  }
}

void QgsQuickMapCanvasMap::onWindowChanged( QQuickWindow *window )
{
  if ( mWindow == window )
    return;

  if ( mWindow )
    disconnect( mWindow, &amp;QQuickWindow::screenChanged, this, &amp;QgsQuickMapCanvasMap::onScreenChanged );

  if ( window )
  {
    connect( window, &amp;QQuickWindow::screenChanged, this, &amp;QgsQuickMapCanvasMap::onScreenChanged );
    onScreenChanged( window-&gt;screen() );
  }

  mWindow = window;
}

void QgsQuickMapCanvasMap::onScreenChanged( QScreen *screen )
{
  if ( screen )
  {
    if ( screen-&gt;devicePixelRatio() &gt; 0 )
    {
      mMapSettings-&gt;setDevicePixelRatio( screen-&gt;devicePixelRatio() );
    }

    mMapSettings-&gt;setOutputDpi( !qgetenv( &quot;QT_SCALE_FACTOR&quot; ).isEmpty() ? screen-&gt;logicalDotsPerInch() : screen-&gt;physicalDotsPerInch() );
  }
}

void QgsQuickMapCanvasMap::onExtentChanged()
{
  updateTransform();

  // And trigger a new rendering job
  refresh();
}

void QgsQuickMapCanvasMap::onRotationChanged()
{
  updateTransform();

  // And trigger a new rendering job
  refresh();
}

void QgsQuickMapCanvasMap::onTemporalStateChanged()
{
  clearTemporalCache();

  // And trigger a new rendering job
  refresh();
}

void QgsQuickMapCanvasMap::onZRangeChanged()
{
  clearElevationCache();

  // And trigger a new rendering job
  refresh();
}

void QgsQuickMapCanvasMap::updateTransform( bool skipSmooth )
{
  const QgsPointXY center = mImageMapSettings.extent().center();
  const QgsPointXY pixelPt = mMapSettings-&gt;coordinateToScreen( QgsPoint( center.x(), center.y() ) );

  if ( mSmooth &amp;&amp; !skipSmooth )
  {
    setProperty( &quot;scale&quot;, ( mImageMapSettings.mapUnitsPerPixel() * mQuality ) / mMapSettings-&gt;mapSettings().mapUnitsPerPixel() );
    setProperty( &quot;rotation&quot;, mMapSettings-&gt;mapSettings().rotation() - mImageMapSettings.rotation() );
    setProperty( &quot;x&quot;, pixelPt.x() - static_cast&lt;qreal&gt;( mMapSettings-&gt;outputSize().width() ) / mMapSettings-&gt;devicePixelRatio() / 2 );
    setProperty( &quot;y&quot;, pixelPt.y() - static_cast&lt;qreal&gt;( mMapSettings-&gt;outputSize().height() ) / mMapSettings-&gt;devicePixelRatio() / 2 );
  }
  else
  {
    setScale( ( mImageMapSettings.mapUnitsPerPixel() * mQuality ) / mMapSettings-&gt;mapSettings().mapUnitsPerPixel() );
    setRotation( mMapSettings-&gt;mapSettings().rotation() - mImageMapSettings.rotation() );
    setX( pixelPt.x() - static_cast&lt;qreal&gt;( mMapSettings-&gt;outputSize().width() ) / mMapSettings-&gt;devicePixelRatio() / 2 );
    setY( pixelPt.y() - static_cast&lt;qreal&gt;( mMapSettings-&gt;outputSize().height() ) / mMapSettings-&gt;devicePixelRatio() / 2 );
  }
}

int QgsQuickMapCanvasMap::mapUpdateInterval() const
{
  return mMapUpdateTimer.interval();
}

void QgsQuickMapCanvasMap::setMapUpdateInterval( int mapUpdateInterval )
{
  if ( mMapUpdateTimer.interval() == mapUpdateInterval )
    return;

  mMapUpdateTimer.setInterval( mapUpdateInterval );

  emit mapUpdateIntervalChanged();
}

bool QgsQuickMapCanvasMap::incrementalRendering() const
{
  return mIncrementalRendering;
}

void QgsQuickMapCanvasMap::setIncrementalRendering( bool incrementalRendering )
{
  if ( incrementalRendering == mIncrementalRendering )
    return;

  mIncrementalRendering = incrementalRendering;
  emit incrementalRenderingChanged();
}

double QgsQuickMapCanvasMap::quality() const
{
  return mQuality;
}

void QgsQuickMapCanvasMap::setQuality( double quality )
{
  quality = std::clamp( quality, 0.5, 1.0 );
  if ( mQuality == quality )
    return;

  mQuality = quality;
  emit qualityChanged();

  // And trigger a new rendering job
  refresh();
}

bool QgsQuickMapCanvasMap::smooth() const
{
  return mSmooth;
}

void QgsQuickMapCanvasMap::setSmooth( bool smooth )
{
  if ( mSmooth == smooth )
    return;

  mSmooth = smooth;
  emit smoothChanged();
}

double QgsQuickMapCanvasMap::bottomMargin() const
{
  return mMapSettings-&gt;bottomMargin();
}

void QgsQuickMapCanvasMap::setBottomMargin( double bottomMargin )
{
  if ( mMapSettings-&gt;bottomMargin() == bottomMargin )
    return;

  mMapSettings-&gt;setBottomMargin( bottomMargin );
  emit bottomMarginChanged();
}

double QgsQuickMapCanvasMap::rightMargin() const
{
  return mMapSettings-&gt;rightMargin();
}

void QgsQuickMapCanvasMap::setRightMargin( double rightMargin )
{
  if ( mMapSettings-&gt;rightMargin() == rightMargin )
    return;

  mMapSettings-&gt;setRightMargin( rightMargin );
  emit rightMarginChanged();
}

bool QgsQuickMapCanvasMap::forceDeferredLayersRepaint() const
{
  return mForceDeferredLayersRepaint;
}

void QgsQuickMapCanvasMap::setForceDeferredLayersRepaint( bool deferred )
{
  if ( mForceDeferredLayersRepaint == deferred )
    return;

  mForceDeferredLayersRepaint = deferred;
  emit forceDeferredLayersRepaintChanged();
}

bool QgsQuickMapCanvasMap::freeze() const
{
  return mFreeze;
}

void QgsQuickMapCanvasMap::setFreeze( bool freeze )
{
  if ( freeze == mFreeze )
    return;

  mFreeze = freeze;

  if ( !mFreeze )
  {
    refresh();
  }

  emit freezeChanged();
}

bool QgsQuickMapCanvasMap::isRendering() const
{
  return mJob;
}

QSGNode *QgsQuickMapCanvasMap::updatePaintNode( QSGNode *oldNode, QQuickItem::UpdatePaintNodeData * )
{
  if ( mDirty )
  {
    delete oldNode;
    oldNode = nullptr;
    mDirty = false;
  }

  if ( mImage.isNull() )
  {
    return nullptr;
  }

  QRectF rect( boundingRect() );
  QSizeF size = mImage.size();
  if ( !size.isEmpty() )
    size /= mMapSettings-&gt;devicePixelRatio();

  // Check for resizes that change the w/h ratio
  if ( !rect.isEmpty() &amp;&amp; !size.isEmpty() &amp;&amp; !qgsDoubleNear( rect.width() / rect.height(), ( size.width() ) / static_cast&lt;double&gt;( size.height() ), 3 ) )
  {
    if ( qgsDoubleNear( rect.height(), mImage.height() ) )
    {
      rect.setHeight( rect.width() / size.width() * size.height() );
    }
    else
    {
      rect.setWidth( rect.height() / size.height() * size.width() );
    }
  }

  QSGSimpleTextureNode *node = static_cast&lt;QSGSimpleTextureNode *&gt;( oldNode );
  bool setChildRects = !node;
  if ( !node )
  {
    node = new QSGSimpleTextureNode();
    node-&gt;setFiltering( QSGTexture::Linear );
    QSGTexture *texture = window()-&gt;createTextureFromImage( mImage );
    node-&gt;setTexture( texture );
    node-&gt;setOwnsTexture( true );
    node-&gt;setRect( rect );

    for ( auto [number, previewImage] : mPreviewImages.asKeyValueRange() )
    {
      QSGSimpleTextureNode *childNode = new QSGSimpleTextureNode();
      childNode-&gt;setFiltering( QSGTexture::Linear );
      texture = window()-&gt;createTextureFromImage( previewImage );
      childNode-&gt;setTexture( texture );
      childNode-&gt;setOwnsTexture( true );
      node-&gt;appendChildNode( childNode );
    }
  }
  else if ( node-&gt;rect() != rect )
  {
    node-&gt;setRect( rect );
    setChildRects = true;
  }

  if ( setChildRects )
  {
    const QList&lt;int&gt; numbers = mPreviewImages.keys();
    for ( int i = 0; i &lt; node-&gt;childCount(); i++ )
    {
      const int number = numbers[i];
      QRectF childRect( rect );
      // Adjust left/right
      if ( number == 0 || number == 3 || number == 6 )
      {
        childRect.setLeft( rect.left() - rect.width() );
        childRect.setRight( rect.right() - rect.width() );
      }
      else if ( number == 2 || number == 5 || number == 8 )
      {
        childRect.setLeft( rect.left() + rect.width() );
        childRect.setRight( rect.right() + rect.width() );
      }
      //Adjust top/bottom
      if ( number &lt; 3 )
      {
        childRect.setTop( rect.top() - rect.height() );
        childRect.setBottom( rect.bottom() - rect.height() );
      }
      else if ( number &gt; 5 )
      {
        childRect.setTop( rect.top() + rect.height() );
        childRect.setBottom( rect.bottom() + rect.height() );
      }

      static_cast&lt;QSGSimpleTextureNode *&gt;( node-&gt;childAtIndex( i ) )-&gt;setRect( childRect );
    }
  }

  return node;
}

void QgsQuickMapCanvasMap::geometryChange( const QRectF &amp;newGeometry, const QRectF &amp;oldGeometry )
{
  QQuickItem::geometryChange( newGeometry, oldGeometry );
  if ( newGeometry.size() != oldGeometry.size() )
  {
    mMapSettings-&gt;setOutputSize( newGeometry.size().toSize() );
    refresh();
  }
}

void QgsQuickMapCanvasMap::onLayersChanged()
{
  if ( mMapSettings-&gt;extent().isEmpty() )
    zoomToFullExtent();

  for ( const QMetaObject::Connection &amp;conn : std::as_const( mLayerConnections ) )
  {
    disconnect( conn );
  }
  mLayerConnections.clear();

  const QList&lt;QgsMapLayer *&gt; layers = mMapSettings-&gt;layers();
  for ( const QgsMapLayer *layer : layers )
  {
    mLayerConnections &lt;&lt; connect( layer, &amp;QgsMapLayer::repaintRequested, this, &amp;QgsQuickMapCanvasMap::layerRepaintRequested );
  }

  refresh();
}

void QgsQuickMapCanvasMap::destroyJob( QgsMapRendererJob *job )
{
  job-&gt;cancel();
  job-&gt;deleteLater();
}

void QgsQuickMapCanvasMap::stopRendering()
{
  if ( mJob )
  {
    mMapUpdateTimer.stop();

    disconnect( mJob, &amp;QgsMapRendererJob::renderingLayersFinished, this, &amp;QgsQuickMapCanvasMap::renderJobUpdated );
    disconnect( mJob, &amp;QgsMapRendererJob::finished, this, &amp;QgsQuickMapCanvasMap::renderJobFinished );

    if ( !mJob-&gt;isActive() )
      mJob-&gt;deleteLater();
    else
      connect( mJob, &amp;QgsMapRendererJob::finished, mJob, &amp;QObject::deleteLater );
    mJob-&gt;cancelWithoutBlocking();
    mJob = nullptr;
  }
  stopPreviewJobs();
}

void QgsQuickMapCanvasMap::zoomToFullExtent()
{
  QgsRectangle extent;
  const QList&lt;QgsMapLayer *&gt; layers = mMapSettings-&gt;layers();
  for ( QgsMapLayer *layer : layers )
  {
    if ( mMapSettings-&gt;destinationCrs() != layer-&gt;crs() )
    {
      QgsCoordinateTransform transform( layer-&gt;crs(), mMapSettings-&gt;destinationCrs(), mMapSettings-&gt;transformContext() );
      try
      {
        extent.combineExtentWith( transform.transformBoundingBox( layer-&gt;extent() ) );
      }
      catch ( const QgsCsException &amp; )
      {
        // Ignore extent if it can't be transformed
      }
    }
    else
    {
      extent.combineExtentWith( layer-&gt;extent() );
    }
  }
  mMapSettings-&gt;setExtent( extent );

  refresh();
}

void QgsQuickMapCanvasMap::refresh( bool ignoreFreeze )
{
  if ( mMapSettings-&gt;outputSize().isNull() )
    return; // the map image size has not been set yet

  if ( ignoreFreeze || !mFreeze )
    mRefreshTimer.start( 1 );
}

void QgsQuickMapCanvasMap::clearElevationCache()
{
  if ( mCache )
  {
    bool invalidateLabels = false;
    const QList&lt;QgsMapLayer *&gt; layerList = mMapSettings-&gt;mapSettings().layers();
    for ( QgsMapLayer *layer : layerList )
    {
      if ( layer-&gt;elevationProperties() &amp;&amp; layer-&gt;elevationProperties()-&gt;hasElevation() )
      {
        if ( QgsVectorLayer *vl = qobject_cast&lt;QgsVectorLayer *&gt;( layer ) )
        {
          if ( vl-&gt;labelsEnabled() || vl-&gt;diagramsEnabled() || ( vl-&gt;renderer() &amp;&amp; vl-&gt;renderer()-&gt;flags().testFlag( Qgis::FeatureRendererFlag::AffectsLabeling ) ) )
            invalidateLabels = true;
        }

        if ( layer-&gt;elevationProperties()-&gt;flags() &amp; QgsMapLayerElevationProperties::FlagDontInvalidateCachedRendersWhenRangeChanges )
          continue;

        mCache-&gt;invalidateCacheForLayer( layer );
      }
      else if ( QgsGroupLayer *gl = qobject_cast&lt;QgsGroupLayer *&gt;( layer ) )
      {
        const QList&lt;QgsMapLayer *&gt; childLayers = gl-&gt;childLayers();
        auto match = std::find_if( childLayers.begin(), childLayers.end(), []( QgsMapLayer *layer ) {
          return layer-&gt;elevationProperties() &amp;&amp; layer-&gt;elevationProperties()-&gt;hasElevation() &amp;&amp; !( layer-&gt;elevationProperties()-&gt;flags() &amp; QgsMapLayerElevationProperties::FlagDontInvalidateCachedRendersWhenRangeChanges );
        } );
        if ( match != childLayers.end() )
        {
          mCache-&gt;invalidateCacheForLayer( layer );
          break;
        }
      }
    }

    if ( invalidateLabels )
    {
      mCache-&gt;clearCacheImage( QStringLiteral( &quot;_labels_&quot; ) );
      mCache-&gt;clearCacheImage( QStringLiteral( &quot;_preview_labels_&quot; ) );
    }
  }
}

void QgsQuickMapCanvasMap::clearTemporalCache()
{
  if ( mCache )
  {
    bool invalidateLabels = false;
    const QList&lt;QgsMapLayer *&gt; layerList = mMapSettings-&gt;mapSettings().layers();
    for ( QgsMapLayer *layer : layerList )
    {
      bool alreadyInvalidatedThisLayer = false;
      if ( QgsVectorLayer *vl = qobject_cast&lt;QgsVectorLayer *&gt;( layer ) )
      {
        if ( vl-&gt;renderer() &amp;&amp; QgsSymbolLayerUtils::rendererFrameRate( vl-&gt;renderer() ) &gt; -1 )
        {
          // layer has an animated symbol assigned, so we have to redraw it regardless of whether
          // or not it has temporal settings
          mCache-&gt;invalidateCacheForLayer( layer );
          alreadyInvalidatedThisLayer = true;
          // we can't shortcut and &quot;continue&quot; here, as we still need to check whether the layer
          // will cause label invalidation using the logic below
        }
      }

      if ( layer-&gt;temporalProperties() &amp;&amp; layer-&gt;temporalProperties()-&gt;isActive() )
      {
        if ( QgsVectorLayer *vl = qobject_cast&lt;QgsVectorLayer *&gt;( layer ) )
        {
          if ( vl-&gt;labelsEnabled() || vl-&gt;diagramsEnabled() || ( vl-&gt;renderer() &amp;&amp; vl-&gt;renderer()-&gt;flags().testFlag( Qgis::FeatureRendererFlag::AffectsLabeling ) ) )
            invalidateLabels = true;
        }

        if ( layer-&gt;temporalProperties()-&gt;flags() &amp; QgsTemporalProperty::FlagDontInvalidateCachedRendersWhenRangeChanges )
          continue;

        if ( !alreadyInvalidatedThisLayer )
        {
          mCache-&gt;invalidateCacheForLayer( layer );
        }
      }
      else if ( QgsGroupLayer *gl = qobject_cast&lt;QgsGroupLayer *&gt;( layer ) )
      {
        const QList&lt;QgsMapLayer *&gt; childLayers = gl-&gt;childLayers();
        auto match = std::find_if( childLayers.begin(), childLayers.end(), []( QgsMapLayer *layer ) {
          return layer-&gt;temporalProperties() &amp;&amp; layer-&gt;temporalProperties()-&gt;isActive() &amp;&amp; !( layer-&gt;temporalProperties()-&gt;flags() &amp; QgsTemporalProperty::FlagDontInvalidateCachedRendersWhenRangeChanges );
        } );
        if ( match != childLayers.end() )
        {
          mCache-&gt;invalidateCacheForLayer( layer );
          break;
        }
      }
    }

    if ( invalidateLabels )
    {
      mCache-&gt;clearCacheImage( QStringLiteral( &quot;_labels_&quot; ) );
      mCache-&gt;clearCacheImage( QStringLiteral( &quot;_preview_labels_&quot; ) );
    }
  }
}

QList&lt;QgsMapLayer *&gt; filterLayersForRender( const QList&lt;QgsMapLayer *&gt; &amp;layers )
{
  QList&lt;QgsMapLayer *&gt; filteredLayers;
  for ( QgsMapLayer *layer : layers )
  {
    if ( QgsAnnotationLayer *annotationLayer = qobject_cast&lt;QgsAnnotationLayer *&gt;( layer ) )
    {
      if ( const QgsMapLayer *linkedLayer = annotationLayer-&gt;linkedVisibilityLayer() )
      {
        if ( !layers.contains( linkedLayer ) )
          continue;
      }
    }
    filteredLayers.append( layer );
  }
  return filteredLayers;
}

bool QgsQuickMapCanvasMap::previewJobsEnabled() const
{
  return mPreviewJobsEnabled;
}

void QgsQuickMapCanvasMap::setPreviewJobsEnabled( bool enabled )
{
  if ( mPreviewJobsEnabled == enabled )
    return;

  mPreviewJobsEnabled = enabled;
  emit previewJobsEnabledChanged();

  if ( !mPreviewJobsEnabled )
  {
    // Clear previously stored preview images
    mPreviewImages.clear();
  }
}

QList&lt;int&gt; QgsQuickMapCanvasMap::previewJobsQuadrants() const
{
  return mPreviewJobsQuadrants;
}

void QgsQuickMapCanvasMap::setPreviewJobsQuadrants( const QList&lt;int&gt; &amp;quadrants )
{
  if ( mPreviewJobsQuadrants == quadrants )
    return;

  mPreviewJobsQuadrants = quadrants;
  emit previewJobsQuadrantsChanged();
}

void QgsQuickMapCanvasMap::startPreviewJobs()
{
  stopPreviewJobs();
  mPreviewImages.clear();

  if ( mImage.isNull() || mPreviewJobsQuadrants.isEmpty() )
  {
    return;
  }

  schedulePreviewJob( 0 );
}

void QgsQuickMapCanvasMap::startPreviewJob( int number )
{
  int quadrant = mPreviewJobsQuadrants.at( number );

  if ( quadrant == 4 )
    quadrant += 1;

  int j = quadrant / 3;
  int i = quadrant % 3;

  QgsMapSettings mapSettings = mImageMapSettings;
  mapSettings.setRotation( 0 );
  const QgsRectangle mapRect = mapSettings.visibleExtent();
  QgsPointXY jobCenter = mapRect.center();
  const double dx = ( i - 1 ) * mapRect.width();
  const double dy = ( 1 - j ) * mapRect.height();
  if ( !qgsDoubleNear( mImageMapSettings.rotation(), 0.0 ) )
  {
    const double radians = mImageMapSettings.rotation() * M_PI / 180;
    const double rdx = dx * cos( radians ) - dy * sin( radians );
    const double rdy = dy * cos( radians ) + dx * sin( radians );
    jobCenter.setX( jobCenter.x() + rdx );
    jobCenter.setY( jobCenter.y() + rdy );
  }
  else
  {
    jobCenter.setX( jobCenter.x() + dx );
    jobCenter.setY( jobCenter.y() + dy );
  }
  const QgsRectangle jobExtent = QgsRectangle::fromCenterAndSize( jobCenter, mapRect.width(), mapRect.height() );

  //copy settings, only update extent
  QgsMapSettings jobSettings = mImageMapSettings;
  jobSettings.setExtent( jobExtent );

  jobSettings.setFlag( Qgis::MapSettingsFlag::DrawLabeling, false );
  jobSettings.setFlag( Qgis::MapSettingsFlag::RenderPreviewJob, true );
  jobSettings.setFlag( Qgis::MapSettingsFlag::RecordProfile, false );

  // truncate preview layers to fast layers
  const QList&lt;QgsMapLayer *&gt; layers = jobSettings.layers();
  QList&lt;QgsMapLayer *&gt; previewLayers;
  QgsDataProvider::PreviewContext context;
  context.maxRenderingTimeMs = Qgis::MAXIMUM_LAYER_PREVIEW_TIME_MS;
  for ( QgsMapLayer *layer : layers )
  {
    if ( layer-&gt;customProperty( QStringLiteral( &quot;rendering/noPreviewJobs&quot; ), false ).toBool() )
    {
      QgsDebugMsgLevel( QStringLiteral( &quot;Layer %1 not rendered because it is explicitly blocked from preview jobs&quot; ).arg( layer-&gt;id() ), 3 );
      continue;
    }
    context.lastRenderingTimeMs = mLastLayerRenderTime.value( layer-&gt;id(), 0 );
    QgsDataProvider *provider = layer-&gt;dataProvider();
    if ( provider &amp;&amp; !provider-&gt;renderInPreview( context ) )
    {
      QgsDebugMsgLevel( QStringLiteral( &quot;Layer %1 not rendered because it does not match the renderInPreview criterion %2&quot; ).arg( layer-&gt;id() ).arg( mLastLayerRenderTime.value( layer-&gt;id() ) ), 3 );
      continue;
    }

    previewLayers &lt;&lt; layer;
  }
  if ( QgsProject::instance()-&gt;mainAnnotationLayer()-&gt;dataProvider()-&gt;renderInPreview( context ) )
  {
    previewLayers.insert( 0, QgsProject::instance()-&gt;mainAnnotationLayer() );
  }
  jobSettings.setLayers( filterLayersForRender( previewLayers ) );
  jobSettings.setOutputImageFormat( QImage::Format_RGBA8888_Premultiplied );

  QgsMapRendererQImageJob *job = new QgsMapRendererSequentialJob( jobSettings );
  job-&gt;setProperty( &quot;number&quot;, number );
  job-&gt;setProperty( &quot;quadrant&quot;, quadrant );
  mPreviewJobs.append( job );
  connect( job, &amp;QgsMapRendererJob::finished, this, &amp;QgsQuickMapCanvasMap::previewJobFinished );
  job-&gt;start();
}

void QgsQuickMapCanvasMap::stopPreviewJobs()
{
  mPreviewTimer.stop();
  for ( auto previewJob = mPreviewJobs.constBegin(); previewJob != mPreviewJobs.constEnd(); ++previewJob )
  {
    if ( *previewJob )
    {
      disconnect( *previewJob, &amp;QgsMapRendererJob::finished, this, &amp;QgsQuickMapCanvasMap::previewJobFinished );
      connect( *previewJob, &amp;QgsMapRendererQImageJob::finished, *previewJob, &amp;QgsMapRendererQImageJob::deleteLater );
      ( *previewJob )-&gt;cancelWithoutBlocking();
    }
  }
  mPreviewJobs.clear();
}

void QgsQuickMapCanvasMap::schedulePreviewJob( int number )
{
  mPreviewTimer.setSingleShot( true );
  mPreviewTimer.setInterval( Qgis::PREVIEW_JOB_DELAY_MS );
  disconnect( mPreviewTimerConnection );
  mPreviewTimerConnection = connect( &amp;mPreviewTimer, &amp;QTimer::timeout, this, [this, number]() {
    startPreviewJob( number );
  } );
  mPreviewTimer.start();
}

void QgsQuickMapCanvasMap::previewJobFinished()
{
  QgsMapRendererQImageJob *job = qobject_cast&lt;QgsMapRendererQImageJob *&gt;( sender() );
  Q_ASSERT( job );

  const int quadrant = job-&gt;property( &quot;quadrant&quot; ).toInt();
  mPreviewImages.insert( quadrant, job-&gt;renderedImage() );
  mPreviewJobs.removeAll( job );

  const int number = job-&gt;property( &quot;number&quot; ).toInt() + 1;
  if ( number &lt; mPreviewJobsQuadrants.size() )
  {
    startPreviewJob( number );
  }
  delete job;

  mDirty = true;
  update();
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 <a href="https://OPENGIS.ch">OPENGIS.ch</a> -  <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC-BY-SA 4.0</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>