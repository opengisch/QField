
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.3">
    
    
      
        <title>File qgsquickelevationprofilecanvas.cpp - QField API Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#file-qgsquickelevationprofilecanvascpp" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="QField API Documentation" class="md-header__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            QField API Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              File qgsquickelevationprofilecanvas.cpp
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.768 3.96zl-.002-.005a9 9 0 0 0-.218-.779c-.13-.394.21-.8.602-.67q.435.144.855.328l.01.005A10.002 10.002 0 0 1 12 22a10 10 0 0 1-9.162-5.985l-.004-.01a10 10 0 0 1-.329-.855c-.13-.392.277-.732.67-.602q.386.126.78.218l.004.002A9 9 0 0 0 14.999 6a9 9 0 0 0-.231-2.04M16.5 6c0 5.799-4.701 10.5-10.5 10.5q-.64 0-1.26-.075A8.5 8.5 0 1 0 16.425 4.74q.075.62.075 1.259Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 19a7 7 0 1 1 0-14 7 7 0 0 1 0 14m0-1.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 1 0 0 11m-5.657.157a.75.75 0 0 1 0 1.06l-1.768 1.768a.749.749 0 0 1-1.275-.326.75.75 0 0 1 .215-.734l1.767-1.768a.75.75 0 0 1 1.061 0M3.515 3.515a.75.75 0 0 1 1.06 0l1.768 1.768a.749.749 0 0 1-.326 1.275.75.75 0 0 1-.734-.215L3.515 4.575a.75.75 0 0 1 0-1.06M12 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 12 0M4 12a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 12m8 8a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 12 20m12-8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 24 12m-6.343 5.657a.75.75 0 0 1 1.06 0l1.768 1.768a.75.75 0 0 1-.018 1.042.75.75 0 0 1-1.042.018l-1.768-1.767a.75.75 0 0 1 0-1.061m2.828-14.142a.75.75 0 0 1 0 1.06l-1.768 1.768a.75.75 0 0 1-1.042-.018.75.75 0 0 1-.018-1.042l1.767-1.768a.75.75 0 0 1 1.061 0"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="QField API Documentation" class="md-nav__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    QField API Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../snippets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Code Snippets
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__core/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    C++ Classes
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__qml/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    QML Items
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="file-qgsquickelevationprofilecanvascpp">File qgsquickelevationprofilecanvas.cpp</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_aebb8dcc11953d78e620bbef0b9e2183/"><strong>core</strong></a> <strong>&gt;</strong> <a href="../dir_19c3d7c8ba6dc95926fecc96295d1560/"><strong>qgsquick</strong></a> <strong>&gt;</strong> <a href="../qgsquickelevationprofilecanvas_8cpp/"><strong>qgsquickelevationprofilecanvas.cpp</strong></a></p>
<p><a href="../qgsquickelevationprofilecanvas_8cpp/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/***************************************************************************
                          QgsQuickElevationProfileCanvas.cpp
                          -----------------
    begin                : October 2022
    copyright            : (C) 2022 by Mathieu Pellerin
    email                : mathieu at opengis dot ch
***************************************************************************/


/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include &quot;qgsabstractprofilegenerator.h&quot;
#include &quot;qgsabstractprofilesource.h&quot;
#include &quot;qgscolorutils.h&quot;
#include &quot;qgsexpressioncontextutils.h&quot;
#include &quot;qgsfillsymbol.h&quot;
#include &quot;qgsfillsymbollayer.h&quot;
#include &quot;qgslinesymbol.h&quot;
#include &quot;qgslinesymbollayer.h&quot;
#include &quot;qgsmaplayerelevationproperties.h&quot;
#include &quot;qgsmaplayerutils.h&quot;
#include &quot;qgsplot.h&quot;
#include &quot;qgsprofilerenderer.h&quot;
#include &quot;qgsprofilerequest.h&quot;
#include &quot;qgsprojectelevationproperties.h&quot;
#include &quot;qgsquickelevationprofilecanvas.h&quot;
#include &quot;qgsterrainprovider.h&quot;

#include &lt;QQuickWindow&gt;
#include &lt;QSGSimpleRectNode&gt;
#include &lt;QSGSimpleTextureNode&gt;
#include &lt;QScreen&gt;
#include &lt;QTimer&gt;

inline QList&lt;QgsMapLayer *&gt; _qgis_listQPointerToRaw( const QgsWeakMapLayerPointerList &amp;layers )
{
  QList&lt;QgsMapLayer *&gt; lst;
  lst.reserve( layers.count() );
  for ( const QgsWeakMapLayerPointer &amp;layerPtr : layers )
  {
    if ( layerPtr )
      lst.append( layerPtr.data() );
  }
  return lst;
}

inline QgsWeakMapLayerPointerList _qgis_listRawToQPointer( const QList&lt;QgsMapLayer *&gt; &amp;layers )
{
  QgsWeakMapLayerPointerList lst;
  lst.reserve( layers.count() );
  for ( QgsMapLayer *layer : layers )
  {
    lst.append( layer );
  }
  return lst;
}


class QgsElevationProfilePlotItem : public Qgs2DPlot
{
  public:
    explicit QgsElevationProfilePlotItem( QgsQuickElevationProfileCanvas *canvas )
      : mCanvas( canvas )
    {
      setYMinimum( 0 );
      setYMaximum( 100 );
      setSize( mCanvas-&gt;boundingRect().size() );
    }

    void setRenderer( QgsProfilePlotRenderer *renderer )
    {
      mRenderer = renderer;
    }

    void updateRect()
    {
      setSize( mCanvas-&gt;boundingRect().size() );
      mCachedImages.clear();
      mPlotArea = QRectF();
    }

    void updatePlot()
    {
      mCachedImages.clear();
      mPlotArea = QRectF();
    }

    bool redrawResults( const QString &amp;sourceId )
    {
      auto it = mCachedImages.find( sourceId );
      if ( it == mCachedImages.end() )
        return false;

      mCachedImages.erase( it );
      return true;
    }

    QRectF plotArea()
    {
      if ( !mPlotArea.isNull() )
        return mPlotArea;

      // force immediate recalculation of plot area
      QgsRenderContext context;
      context.setScaleFactor( ( mCanvas-&gt;window()-&gt;screen()-&gt;physicalDotsPerInch() * mCanvas-&gt;window()-&gt;screen()-&gt;devicePixelRatio() ) / 25.4 );

      calculateOptimisedIntervals( context );
      mPlotArea = interiorPlotArea( context );
      return mPlotArea;
    }

    void renderContent( QgsRenderContext &amp;rc, const QRectF &amp;plotArea ) override
    {
      mPlotArea = plotArea;

      if ( !mRenderer )
        return;

      const QStringList sourceIds = mRenderer-&gt;sourceIds();
      for ( const QString &amp;source : sourceIds )
      {
        QImage plot;
        auto it = mCachedImages.constFind( source );
        if ( it != mCachedImages.constEnd() )
        {
          plot = it.value();
        }
        else
        {
          const double devicePixelRatio = mCanvas-&gt;window()-&gt;screen()-&gt;devicePixelRatio();
          plot = QImage( plotArea.width() * devicePixelRatio, plotArea.height() * devicePixelRatio, QImage::Format_ARGB32_Premultiplied );
          plot.setDevicePixelRatio( devicePixelRatio );
          plot.fill( Qt::transparent );

          QPainter plotPainter( &amp;plot );
          plotPainter.setRenderHint( QPainter::Antialiasing, true );
          QgsRenderContext plotRc = QgsRenderContext::fromQPainter( &amp;plotPainter );
          plotRc.setDevicePixelRatio( devicePixelRatio );
          mRenderer-&gt;render( plotRc, plotArea.width(), plotArea.height(), xMinimum(), xMaximum(), yMinimum(), yMaximum(), source );
          plotPainter.end();

          mCachedImages.insert( source, plot );
        }
        rc.painter()-&gt;drawImage( plotArea.left(), plotArea.top(), plot );
      }
    }

  private:
    QgsQuickElevationProfileCanvas *mCanvas = nullptr;
    QgsProfilePlotRenderer *mRenderer = nullptr;

    QRectF mPlotArea;
    QMap&lt;QString, QImage&gt; mCachedImages;
};


QgsQuickElevationProfileCanvas::QgsQuickElevationProfileCanvas( QQuickItem *parent )
  : QQuickItem( parent )
{
  // updating the profile plot is deferred on a timer, so that we don't trigger it too often
  mDeferredRegenerationTimer = new QTimer( this );
  mDeferredRegenerationTimer-&gt;setSingleShot( true );
  mDeferredRegenerationTimer-&gt;stop();
  connect( mDeferredRegenerationTimer, &amp;QTimer::timeout, this, &amp;QgsQuickElevationProfileCanvas::startDeferredRegeneration );

  mDeferredRedrawTimer = new QTimer( this );
  mDeferredRedrawTimer-&gt;setSingleShot( true );
  mDeferredRedrawTimer-&gt;stop();
  connect( mDeferredRedrawTimer, &amp;QTimer::timeout, this, &amp;QgsQuickElevationProfileCanvas::startDeferredRedraw );

  mPlotItem = new QgsElevationProfilePlotItem( this );
  updateStyle();

  setTransformOrigin( QQuickItem::TopLeft );
  setFlags( QQuickItem::ItemHasContents );
}

QgsQuickElevationProfileCanvas::~QgsQuickElevationProfileCanvas()
{
  if ( mCurrentJob )
  {
    mPlotItem-&gt;setRenderer( nullptr );
    mCurrentJob-&gt;deleteLater();
    mCurrentJob = nullptr;
  }
}

void QgsQuickElevationProfileCanvas::cancelJobs()
{
  if ( mCurrentJob )
  {
    mPlotItem-&gt;setRenderer( nullptr );
    disconnect( mCurrentJob, &amp;QgsProfilePlotRenderer::generationFinished, this, &amp;QgsQuickElevationProfileCanvas::generationFinished );
    mCurrentJob-&gt;cancelGeneration();
    mCurrentJob-&gt;deleteLater();
    mCurrentJob = nullptr;
  }
}

void QgsQuickElevationProfileCanvas::setupLayerConnections( QgsMapLayer *layer, bool isDisconnect )
{
  if ( !layer )
    return;

  if ( isDisconnect )
  {
    disconnect( layer-&gt;elevationProperties(), &amp;QgsMapLayerElevationProperties::profileGenerationPropertyChanged, this, &amp;QgsQuickElevationProfileCanvas::onLayerProfileGenerationPropertyChanged );
    disconnect( layer-&gt;elevationProperties(), &amp;QgsMapLayerElevationProperties::profileRenderingPropertyChanged, this, &amp;QgsQuickElevationProfileCanvas::onLayerProfileRendererPropertyChanged );
    disconnect( layer, &amp;QgsMapLayer::dataChanged, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
  }
  else
  {
    connect( layer-&gt;elevationProperties(), &amp;QgsMapLayerElevationProperties::profileGenerationPropertyChanged, this, &amp;QgsQuickElevationProfileCanvas::onLayerProfileGenerationPropertyChanged );
    connect( layer-&gt;elevationProperties(), &amp;QgsMapLayerElevationProperties::profileRenderingPropertyChanged, this, &amp;QgsQuickElevationProfileCanvas::onLayerProfileRendererPropertyChanged );
    connect( layer, &amp;QgsMapLayer::dataChanged, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
  }

  switch ( layer-&gt;type() )
  {
    case Qgis::LayerType::Vector:
    {
      const QgsVectorLayer *vl = qobject_cast&lt;QgsVectorLayer *&gt;( layer );
      if ( isDisconnect )
      {
        disconnect( vl, &amp;QgsVectorLayer::featureAdded, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
        disconnect( vl, &amp;QgsVectorLayer::featureDeleted, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
        disconnect( vl, &amp;QgsVectorLayer::geometryChanged, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
        disconnect( vl, &amp;QgsVectorLayer::attributeValueChanged, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
      }
      else
      {
        connect( vl, &amp;QgsVectorLayer::featureAdded, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
        connect( vl, &amp;QgsVectorLayer::featureDeleted, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
        connect( vl, &amp;QgsVectorLayer::geometryChanged, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
        connect( vl, &amp;QgsVectorLayer::attributeValueChanged, this, &amp;QgsQuickElevationProfileCanvas::regenerateResultsForLayer );
      }
      break;
    }
    case Qgis::LayerType::Raster:
    case Qgis::LayerType::Plugin:
    case Qgis::LayerType::Mesh:
    case Qgis::LayerType::VectorTile:
    case Qgis::LayerType::Annotation:
    case Qgis::LayerType::PointCloud:
    case Qgis::LayerType::Group:
    case Qgis::LayerType::TiledScene:
      break;
  }
}

bool QgsQuickElevationProfileCanvas::isRendering() const
{
  return mCurrentJob &amp;&amp; mCurrentJob-&gt;isActive();
}

void QgsQuickElevationProfileCanvas::refresh()
{
  if ( !mCrs.isValid() || !mProject || mProfileCurve.isEmpty() )
    return;

  if ( mCurrentJob )
  {
    mPlotItem-&gt;setRenderer( nullptr );
    disconnect( mCurrentJob, &amp;QgsProfilePlotRenderer::generationFinished, this, &amp;QgsQuickElevationProfileCanvas::generationFinished );
    mCurrentJob-&gt;deleteLater();
    mCurrentJob = nullptr;
  }

  QgsProfileRequest request( static_cast&lt;QgsCurve *&gt;( mProfileCurve.get()-&gt;clone() ) );
  request.setCrs( mCrs );
  request.setTolerance( mTolerance );
  request.setTransformContext( mProject-&gt;transformContext() );
  request.setTerrainProvider( mProject-&gt;elevationProperties()-&gt;terrainProvider() ? mProject-&gt;elevationProperties()-&gt;terrainProvider()-&gt;clone() : nullptr );

  QgsExpressionContext context;
  context.appendScope( QgsExpressionContextUtils::globalScope() );
  context.appendScope( QgsExpressionContextUtils::projectScope( mProject ) );
  request.setExpressionContext( context );

  const QList&lt;QgsMapLayer *&gt; layersToGenerate = layers();
  QList&lt;QgsAbstractProfileSource *&gt; sources;
  sources.reserve( layersToGenerate.size() );
  for ( QgsMapLayer *layer : layersToGenerate )
  {
    if ( QgsAbstractProfileSource *source = dynamic_cast&lt;QgsAbstractProfileSource *&gt;( layer ) ) // cppcheck-suppress constVariablePointer
    {
      sources.append( source );
    }
  }

  mCurrentJob = new QgsProfilePlotRenderer( sources, request );
  connect( mCurrentJob, &amp;QgsProfilePlotRenderer::generationFinished, this, &amp;QgsQuickElevationProfileCanvas::generationFinished );

  QgsProfileGenerationContext generationContext;
  generationContext.setDpi( window()-&gt;screen()-&gt;physicalDotsPerInch() * window()-&gt;screen()-&gt;devicePixelRatio() );
  generationContext.setMaximumErrorMapUnits( MAX_ERROR_PIXELS * ( mProfileCurve.get()-&gt;length() ) / mPlotItem-&gt;plotArea().width() );
  generationContext.setMapUnitsPerDistancePixel( mProfileCurve.get()-&gt;length() / mPlotItem-&gt;plotArea().width() );
  mCurrentJob-&gt;setContext( generationContext );

  mPlotItem-&gt;updatePlot();
  mCurrentJob-&gt;startGeneration();
  mPlotItem-&gt;setRenderer( mCurrentJob );

  emit activeJobCountChanged( 1 );
  emit isRenderingChanged();
}

void QgsQuickElevationProfileCanvas::generationFinished()
{
  if ( !mCurrentJob )
    return;

  emit activeJobCountChanged( 0 );

  if ( mZoomFullWhenJobFinished )
  {
    mZoomFullWhenJobFinished = false;
    zoomFull();
  }

  QRectF rect = boundingRect();
  const double devicePixelRatio = window()-&gt;screen()-&gt;devicePixelRatio();
  mImage = QImage( rect.width() * devicePixelRatio, rect.height() * devicePixelRatio, QImage::Format_ARGB32_Premultiplied );
  mImage.setDevicePixelRatio( devicePixelRatio );
  mImage.fill( Qt::transparent );

  QPainter imagePainter( &amp;mImage );
  imagePainter.setRenderHint( QPainter::Antialiasing, true );
  QgsRenderContext rc = QgsRenderContext::fromQPainter( &amp;imagePainter );
  rc.setDevicePixelRatio( devicePixelRatio );

  rc.expressionContext().appendScope( QgsExpressionContextUtils::globalScope() );
  rc.expressionContext().appendScope( QgsExpressionContextUtils::projectScope( mProject ) );

  mPlotItem-&gt;calculateOptimisedIntervals( rc );
  mPlotItem-&gt;render( rc );
  imagePainter.end();

  mDirty = true;
  update();

  if ( mForceRegenerationAfterCurrentJobCompletes )
  {
    mForceRegenerationAfterCurrentJobCompletes = false;
    mCurrentJob-&gt;invalidateAllRefinableSources();
    scheduleDeferredRegeneration();
  }
  else
  {
    emit isRenderingChanged();
  }
}

void QgsQuickElevationProfileCanvas::onLayerProfileGenerationPropertyChanged()
{
  // TODO -- handle nicely when existing job is in progress
  if ( !mCurrentJob || mCurrentJob-&gt;isActive() )
    return;

  QgsMapLayerElevationProperties *properties = qobject_cast&lt;QgsMapLayerElevationProperties *&gt;( sender() );
  if ( !properties )
    return;

  if ( QgsMapLayer *layer = qobject_cast&lt;QgsMapLayer *&gt;( properties-&gt;parent() ) )
  {
    if ( QgsAbstractProfileSource *source = dynamic_cast&lt;QgsAbstractProfileSource *&gt;( layer ) )
    {
      if ( mCurrentJob-&gt;invalidateResults( source ) )
        scheduleDeferredRegeneration();
    }
  }
}

void QgsQuickElevationProfileCanvas::onLayerProfileRendererPropertyChanged()
{
  // TODO -- handle nicely when existing job is in progress
  if ( !mCurrentJob || mCurrentJob-&gt;isActive() )
    return;

  QgsMapLayerElevationProperties *properties = qobject_cast&lt;QgsMapLayerElevationProperties *&gt;( sender() );
  if ( !properties )
    return;

  if ( QgsMapLayer *layer = qobject_cast&lt;QgsMapLayer *&gt;( properties-&gt;parent() ) )
  {
    if ( QgsAbstractProfileSource *source = dynamic_cast&lt;QgsAbstractProfileSource *&gt;( layer ) )
    {
      mCurrentJob-&gt;replaceSource( source );
    }
    if ( mPlotItem-&gt;redrawResults( layer-&gt;id() ) )
      scheduleDeferredRedraw();
  }
}

void QgsQuickElevationProfileCanvas::regenerateResultsForLayer()
{
  if ( !mCurrentJob )
    return;

  if ( QgsMapLayer *layer = qobject_cast&lt;QgsMapLayer *&gt;( sender() ) )
  {
    if ( QgsAbstractProfileSource *source = dynamic_cast&lt;QgsAbstractProfileSource *&gt;( layer ) )
    {
      if ( mCurrentJob-&gt;invalidateResults( source ) )
        scheduleDeferredRegeneration();
    }
  }
}

void QgsQuickElevationProfileCanvas::scheduleDeferredRegeneration()
{
  if ( !mDeferredRegenerationScheduled )
  {
    mDeferredRegenerationTimer-&gt;start( 1 );
    mDeferredRegenerationScheduled = true;
  }
}

void QgsQuickElevationProfileCanvas::scheduleDeferredRedraw()
{
  if ( !mDeferredRedrawScheduled )
  {
    mDeferredRedrawTimer-&gt;start( 1 );
    mDeferredRedrawScheduled = true;
  }
}

void QgsQuickElevationProfileCanvas::startDeferredRegeneration()
{
  if ( mCurrentJob &amp;&amp; !mCurrentJob-&gt;isActive() )
  {
    emit activeJobCountChanged( 1 );
    mCurrentJob-&gt;regenerateInvalidatedResults();
  }
  else if ( mCurrentJob )
  {
    mForceRegenerationAfterCurrentJobCompletes = true;
  }

  mDeferredRegenerationScheduled = false;
}

void QgsQuickElevationProfileCanvas::startDeferredRedraw()
{
  refresh();
  mDeferredRedrawScheduled = false;
}

void QgsQuickElevationProfileCanvas::refineResults()
{
  if ( mCurrentJob )
  {
    QgsProfileGenerationContext context;
    context.setDpi( window()-&gt;screen()-&gt;physicalDotsPerInch() * window()-&gt;screen()-&gt;devicePixelRatio() );
    const double plotDistanceRange = mPlotItem-&gt;xMaximum() - mPlotItem-&gt;xMinimum();
    const double plotElevationRange = mPlotItem-&gt;yMaximum() - mPlotItem-&gt;yMinimum();
    const double plotDistanceUnitsPerPixel = plotDistanceRange / mPlotItem-&gt;plotArea().width();

    // we round the actual desired map error down to just one significant figure, to avoid tiny differences
    // as the plot is panned
    const double targetMaxErrorInMapUnits = MAX_ERROR_PIXELS * plotDistanceUnitsPerPixel;
    const double factor = std::pow( 10.0, 1 - std::ceil( std::log10( std::fabs( targetMaxErrorInMapUnits ) ) ) );
    const double roundedErrorInMapUnits = std::floor( targetMaxErrorInMapUnits * factor ) / factor;
    context.setMaximumErrorMapUnits( roundedErrorInMapUnits );

    context.setMapUnitsPerDistancePixel( plotDistanceUnitsPerPixel );

    // for similar reasons we round the minimum distance off to multiples of the maximum error in map units
    const double distanceMin = std::floor( ( mPlotItem-&gt;xMinimum() - plotDistanceRange * 0.05 ) / context.maximumErrorMapUnits() ) * context.maximumErrorMapUnits();
    context.setDistanceRange( QgsDoubleRange( std::max( 0.0, distanceMin ),
                                              mPlotItem-&gt;xMaximum() + plotDistanceRange * 0.05 ) );

    context.setElevationRange( QgsDoubleRange( mPlotItem-&gt;yMinimum() - plotElevationRange * 0.05,
                                               mPlotItem-&gt;yMaximum() + plotElevationRange * 0.05 ) );
    mCurrentJob-&gt;setContext( context );
  }
  scheduleDeferredRegeneration();
}

void QgsQuickElevationProfileCanvas::setProject( QgsProject *project )
{
  if ( mProject == project )
    return;

  mProject = project;

  emit projectChanged();
}

void QgsQuickElevationProfileCanvas::setCrs( const QgsCoordinateReferenceSystem &amp;crs )
{
  if ( mCrs == crs )
    return;

  mCrs = crs;

  emit crsChanged();
}

void QgsQuickElevationProfileCanvas::setProfileCurve( QgsGeometry curve )
{
  if ( mProfileCurve.equals( curve ) )
    return;

  mProfileCurve = curve.type() == Qgis::GeometryType::Line ? curve : QgsGeometry();

  emit profileCurveChanged();
}

void QgsQuickElevationProfileCanvas::setTolerance( double tolerance )
{
  if ( mTolerance == tolerance )
    return;

  mTolerance = tolerance;

  emit toleranceChanged();
}

void QgsQuickElevationProfileCanvas::populateLayersFromProject()
{
  for ( QgsMapLayer *layer : std::as_const( mLayers ) )
  {
    setupLayerConnections( layer, true );
  }

  if ( !mProject )
  {
    mLayers.clear();
    return;
  }

  const QList&lt;QgsMapLayer *&gt; projectLayers = QgsProject::instance()-&gt;layers&lt;QgsMapLayer *&gt;().toList();
  // sort layers so that types which are more likely to obscure others are rendered below
  // e.g. vector features should be drawn above raster DEMS, or the DEM line may completely obscure
  // the vector feature
  QList&lt;QgsMapLayer *&gt; sortedLayers = QgsMapLayerUtils::sortLayersByType( projectLayers,
                                                                          { Qgis::LayerType::Raster,
                                                                            Qgis::LayerType::Mesh,
                                                                            Qgis::LayerType::Vector,
                                                                            Qgis::LayerType::PointCloud } );

  // filter list, removing null layers and invalid layers
  auto filteredList = sortedLayers;
  filteredList.erase( std::remove_if( filteredList.begin(), filteredList.end(),
                                      []( QgsMapLayer *layer ) {
                                        return !layer || !layer-&gt;isValid() || !layer-&gt;elevationProperties() || !layer-&gt;elevationProperties()-&gt;showByDefaultInElevationProfilePlots();
                                      } ),
                      filteredList.end() );

  mLayers = _qgis_listRawToQPointer( filteredList );
  for ( QgsMapLayer *layer : std::as_const( mLayers ) )
  {
    setupLayerConnections( layer, false );
  }
}

QList&lt;QgsMapLayer *&gt; QgsQuickElevationProfileCanvas::layers() const
{
  return _qgis_listQPointerToRaw( mLayers );
}

void QgsQuickElevationProfileCanvas::geometryChange( const QRectF &amp;newGeometry, const QRectF &amp;oldGeometry )
{
  QQuickItem::geometryChange( newGeometry, oldGeometry );
  mPlotItem-&gt;updateRect();
  mDirty = true;
  refresh();
}

QSGNode *QgsQuickElevationProfileCanvas::updatePaintNode( QSGNode *oldNode, QQuickItem::UpdatePaintNodeData * )
{
  if ( mDirty )
  {
    delete oldNode;
    oldNode = nullptr;
    mDirty = false;
  }

  QSGNode *newNode = nullptr;
  if ( !mImage.isNull() )
  {
    QSGSimpleTextureNode *node = static_cast&lt;QSGSimpleTextureNode *&gt;( oldNode );
    if ( !node )
    {
      node = new QSGSimpleTextureNode();
      QSGTexture *texture = window()-&gt;createTextureFromImage( mImage );
      node-&gt;setTexture( texture );
      node-&gt;setOwnsTexture( true );
    }

    QRectF rect( boundingRect() );
    QSizeF size = mImage.size();
    if ( !size.isEmpty() )
      size /= window()-&gt;screen()-&gt;devicePixelRatio();

    // Check for resizes that change the w/h ratio
    if ( !rect.isEmpty() &amp;&amp; !size.isEmpty() &amp;&amp; !qgsDoubleNear( rect.width() / rect.height(), ( size.width() ) / static_cast&lt;double&gt;( size.height() ), 3 ) )
    {
      if ( qgsDoubleNear( rect.height(), mImage.height() ) )
      {
        rect.setHeight( rect.width() / size.width() * size.height() );
      }
      else
      {
        rect.setWidth( rect.height() / size.height() * size.width() );
      }
    }
    node-&gt;setRect( rect );
    newNode = node;
  }
  else
  {
    QSGSimpleRectNode *node = static_cast&lt;QSGSimpleRectNode *&gt;( oldNode );
    if ( !node )
    {
      node = new QSGSimpleRectNode();
      node-&gt;setColor( Qt::transparent );
    }
    node-&gt;setRect( boundingRect() );
    newNode = node;
  }

  return newNode;
}

void QgsQuickElevationProfileCanvas::zoomFull()
{
  if ( !mCurrentJob )
    return;

  const QgsDoubleRange zRange = mCurrentJob-&gt;zRange();

  if ( zRange.upper() &lt; zRange.lower() )
  {
    // invalid range, e.g. no features found in plot!
    mPlotItem-&gt;setYMinimum( 0 );
    mPlotItem-&gt;setYMaximum( 10 );
  }
  else if ( qgsDoubleNear( zRange.lower(), zRange.upper(), 0.0000001 ) )
  {
    // corner case ... a zero height plot! Just pick an arbitrary +/- 5 height range.
    mPlotItem-&gt;setYMinimum( zRange.lower() - 5 );
    mPlotItem-&gt;setYMaximum( zRange.lower() + 5 );
  }
  else
  {
    // add 5% margin to height range
    const double margin = ( zRange.upper() - zRange.lower() ) * 0.05;
    mPlotItem-&gt;setYMinimum( zRange.lower() - margin );
    mPlotItem-&gt;setYMaximum( zRange.upper() + margin );
  }

  const double profileLength = mProfileCurve.get()-&gt;length();
  mPlotItem-&gt;setXMinimum( 0 );
  // just 2% margin to max distance -- any more is overkill and wasted space
  mPlotItem-&gt;setXMaximum( profileLength * 1.02 );

  refineResults();
}

void QgsQuickElevationProfileCanvas::zoomFullInRatio()
{
  if ( !mCurrentJob )
    return;

  const QgsDoubleRange zRange = mCurrentJob-&gt;zRange();
  double xLength = mProfileCurve.get()-&gt;length();
  double yLength = zRange.upper() - zRange.lower();
  if ( yLength &lt; 0.0 )
  {
    // invalid range, e.g. no features found in plot!
    mPlotItem-&gt;setYMinimum( 0 );
    mPlotItem-&gt;setYMaximum( 10 );

    mPlotItem-&gt;setXMinimum( 0 );
    // just 2% margin to max distance -- any more is overkill and wasted space
    mPlotItem-&gt;setXMaximum( xLength * 1.02 );
  }
  else
  {
    double yInRatioLength = xLength * mPlotItem-&gt;size().height() / mPlotItem-&gt;size().width();
    double xInRatioLength = yLength * mPlotItem-&gt;size().width() / mPlotItem-&gt;size().height();
    if ( yInRatioLength &gt; yLength )
    {
      mPlotItem-&gt;setYMinimum( zRange.lower() - ( yInRatioLength / 2 ) );
      mPlotItem-&gt;setYMaximum( zRange.upper() + ( yInRatioLength / 2 ) );

      mPlotItem-&gt;setXMinimum( 0 );
      // just 2% margin to max distance -- any more is overkill and wasted space
      mPlotItem-&gt;setXMaximum( xLength * 1.02 );
    }
    else
    {
      // add 5% margin to height range
      const double margin = yLength * 0.05;
      mPlotItem-&gt;setYMinimum( zRange.lower() - margin );
      mPlotItem-&gt;setYMaximum( zRange.upper() + margin );

      mPlotItem-&gt;setXMinimum( 0 - ( xInRatioLength / 2 ) );
      mPlotItem-&gt;setXMaximum( xLength + ( xInRatioLength / 2 ) );
    }
  }

  refineResults();
}

void QgsQuickElevationProfileCanvas::setVisiblePlotRange( double minimumDistance, double maximumDistance, double minimumElevation, double maximumElevation )
{
  mPlotItem-&gt;setYMinimum( minimumElevation );
  mPlotItem-&gt;setYMaximum( maximumElevation );
  mPlotItem-&gt;setXMinimum( minimumDistance );
  mPlotItem-&gt;setXMaximum( maximumDistance );
  refineResults();
}

QColor QgsQuickElevationProfileCanvas::backgroundColor() const
{
  return mBackgroundColor;
}

void QgsQuickElevationProfileCanvas::setBackgroundColor( const QColor &amp;color )
{
  if ( mBackgroundColor == color )
    return;

  mBackgroundColor = color;
  emit backgroundColorChanged();

  updateStyle();
}

QColor QgsQuickElevationProfileCanvas::borderColor() const
{
  return mBorderColor;
}

void QgsQuickElevationProfileCanvas::setBorderColor( const QColor &amp;color )
{
  if ( mBorderColor == color )
    return;

  mBorderColor = color;
  emit borderColorChanged();

  updateStyle();
}

QColor QgsQuickElevationProfileCanvas::axisLabelColor() const
{
  return mAxisLabelColor;
}

void QgsQuickElevationProfileCanvas::setAxisLabelColor( const QColor &amp;color )
{
  if ( mAxisLabelColor == color )
    return;

  mAxisLabelColor = color;
  emit axisLabelColorChanged();

  updateStyle();
}

double QgsQuickElevationProfileCanvas::axisLabelSize() const
{
  return mAxisLabelSize;
}

void QgsQuickElevationProfileCanvas::setAxisLabelSize( double size )
{
  if ( mAxisLabelSize == size )
    return;

  mAxisLabelSize = size;
  emit axisLabelSizeChanged();

  updateStyle();
}

void QgsQuickElevationProfileCanvas::updateStyle()
{
  if ( mPlotItem )
  {
    QgsTextFormat textFormat = mPlotItem-&gt;xAxis().textFormat();
    textFormat.setColor( mAxisLabelColor );
    textFormat.setSize( mAxisLabelSize );
    textFormat.setSizeUnit( Qgis::RenderUnit::Points );
    mPlotItem-&gt;xAxis().setTextFormat( textFormat );

    textFormat = mPlotItem-&gt;yAxis().textFormat();
    textFormat.setColor( mAxisLabelColor );
    textFormat.setSize( mAxisLabelSize );
    textFormat.setSizeUnit( Qgis::RenderUnit::Points );
    mPlotItem-&gt;yAxis().setTextFormat( textFormat );

    std::unique_ptr&lt;QgsSimpleLineSymbolLayer&gt; lineSymbolLayer = std::make_unique&lt;QgsSimpleLineSymbolLayer&gt;( mBorderColor, 0.1 );
    lineSymbolLayer-&gt;setPenCapStyle( Qt::FlatCap );
    mPlotItem-&gt;xAxis().setGridMinorSymbol( new QgsLineSymbol( QgsSymbolLayerList( { lineSymbolLayer-&gt;clone() } ) ) );
    mPlotItem-&gt;yAxis().setGridMinorSymbol( new QgsLineSymbol( QgsSymbolLayerList( { lineSymbolLayer-&gt;clone() } ) ) );
    mPlotItem-&gt;xAxis().setGridMajorSymbol( new QgsLineSymbol( QgsSymbolLayerList( { lineSymbolLayer-&gt;clone() } ) ) );
    mPlotItem-&gt;yAxis().setGridMajorSymbol( new QgsLineSymbol( QgsSymbolLayerList( { lineSymbolLayer-&gt;clone() } ) ) );
    mPlotItem-&gt;setChartBorderSymbol( new QgsFillSymbol( QgsSymbolLayerList( { lineSymbolLayer.release() } ) ) );
    std::unique_ptr&lt;QgsSimpleFillSymbolLayer&gt; fillSymbolLayer = std::make_unique&lt;QgsSimpleFillSymbolLayer&gt;( mBackgroundColor, Qt::SolidPattern, mBackgroundColor );
    mPlotItem-&gt;setChartBackgroundSymbol( new QgsFillSymbol( QgsSymbolLayerList( { fillSymbolLayer.release() } ) ) );

    mDirty = true;
    refresh();
  }
}

QgsDoubleRange QgsQuickElevationProfileCanvas::visibleDistanceRange() const
{
  return QgsDoubleRange( mPlotItem-&gt;xMinimum(), mPlotItem-&gt;xMaximum() );
}

QgsDoubleRange QgsQuickElevationProfileCanvas::visibleElevationRange() const
{
  return QgsDoubleRange( mPlotItem-&gt;yMinimum(), mPlotItem-&gt;yMaximum() );
}

void QgsQuickElevationProfileCanvas::clear()
{
  setProfileCurve( QgsGeometry() );
  if ( mCurrentJob )
  {
    mPlotItem-&gt;setRenderer( nullptr );
    disconnect( mCurrentJob, &amp;QgsProfilePlotRenderer::generationFinished, this, &amp;QgsQuickElevationProfileCanvas::generationFinished );
    mCurrentJob-&gt;deleteLater();
    mCurrentJob = nullptr;
  }

  mZoomFullWhenJobFinished = true;

  mImage = QImage();
  mDirty = true;
  update();
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 <a href="https://OPENGIS.ch">OPENGIS.ch</a> -  <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC-BY-SA 4.0</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>