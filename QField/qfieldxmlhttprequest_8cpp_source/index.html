
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.3">
    
    
      
        <title>File qfieldxmlhttprequest.cpp - QField API Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#file-qfieldxmlhttprequestcpp" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="QField API Documentation" class="md-header__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            QField API Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              File qfieldxmlhttprequest.cpp
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.768 3.96zl-.002-.005a9 9 0 0 0-.218-.779c-.13-.394.21-.8.602-.67q.435.144.855.328l.01.005A10.002 10.002 0 0 1 12 22a10 10 0 0 1-9.162-5.985l-.004-.01a10 10 0 0 1-.329-.855c-.13-.392.277-.732.67-.602q.386.126.78.218l.004.002A9 9 0 0 0 14.999 6a9 9 0 0 0-.231-2.04M16.5 6c0 5.799-4.701 10.5-10.5 10.5q-.64 0-1.26-.075A8.5 8.5 0 1 0 16.425 4.74q.075.62.075 1.259Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 19a7 7 0 1 1 0-14 7 7 0 0 1 0 14m0-1.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 1 0 0 11m-5.657.157a.75.75 0 0 1 0 1.06l-1.768 1.768a.749.749 0 0 1-1.275-.326.75.75 0 0 1 .215-.734l1.767-1.768a.75.75 0 0 1 1.061 0M3.515 3.515a.75.75 0 0 1 1.06 0l1.768 1.768a.749.749 0 0 1-.326 1.275.75.75 0 0 1-.734-.215L3.515 4.575a.75.75 0 0 1 0-1.06M12 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 12 0M4 12a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 12m8 8a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 12 20m12-8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 24 12m-6.343 5.657a.75.75 0 0 1 1.06 0l1.768 1.768a.75.75 0 0 1-.018 1.042.75.75 0 0 1-1.042.018l-1.768-1.767a.75.75 0 0 1 0-1.061m2.828-14.142a.75.75 0 0 1 0 1.06l-1.768 1.768a.75.75 0 0 1-1.042-.018.75.75 0 0 1-.018-1.042l1.767-1.768a.75.75 0 0 1 1.061 0"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="QField API Documentation" class="md-nav__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    QField API Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../snippets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Code Snippets
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__core/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    C++ Classes
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__qml/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    QML Items
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="file-qfieldxmlhttprequestcpp">File qfieldxmlhttprequest.cpp</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_aebb8dcc11953d78e620bbef0b9e2183/"><strong>core</strong></a> <strong>&gt;</strong> <a href="../qfieldxmlhttprequest_8cpp/"><strong>qfieldxmlhttprequest.cpp</strong></a></p>
<p><a href="../qfieldxmlhttprequest_8cpp/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/***************************************************************************
qfieldxmlhttprequest.cpp - QFieldXmlHttpRequest

---------------------
begin                : 15.12.2025
copyright            : (C) 2025 by Kaustuv Pokharel
email                : kaustuv (at) opengis.ch
***************************************************************************
*                                                                         *
*   This program is free software; you can redistribute it and/or modify  *
*   it under the terms of the GNU General Public License as published by  *
*   the Free Software Foundation; either version 2 of the License, or     *
*   (at your option) any later version.                                   *
*                                                                         *
***************************************************************************/

#include &quot;qfieldxmlhttprequest.h&quot;

#include &lt;QDebug&gt;
#include &lt;QDir&gt;
#include &lt;QFile&gt;
#include &lt;QFileInfo&gt;
#include &lt;QHttpMultiPart&gt;
#include &lt;QHttpPart&gt;
#include &lt;QJsonDocument&gt;
#include &lt;QJsonObject&gt;
#include &lt;QJsonParseError&gt;
#include &lt;QJsonValue&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QTimer&gt;
#include &lt;qfieldcloudutils.h&gt;
#include &lt;qgsnetworkaccessmanager.h&gt;

#include &lt;algorithm&gt;
#include &lt;fileutils.h&gt;
#include &lt;urlutils.h&gt;

namespace
{
  bool isFileUrlString( const QString &amp;stringValue )
  {
    return stringValue.trimmed().startsWith( QStringLiteral( &quot;file://&quot; ), Qt::CaseInsensitive );
  }
} // namespace

QFieldXmlHttpRequest::QFieldXmlHttpRequest( QObject *parent )
  : QObject( parent )
{
}

QFieldXmlHttpRequest::~QFieldXmlHttpRequest()
{
  // Destructor must be silent (no QML callbacks / no signals)
  cleanupReply( true );
}

QFieldXmlHttpRequest *QFieldXmlHttpRequest::newRequest( QObject *parent )
{
  return new QFieldXmlHttpRequest( parent );
}

void QFieldXmlHttpRequest::setTimeout( int milliseconds )
{
  const int timeoutMilliseconds = milliseconds &gt; 0 ? milliseconds : 0;
  if ( mTimeoutMs == timeoutMilliseconds )
  {
    return;
  }

  mTimeoutMs = timeoutMilliseconds;
  emit timeoutChanged();
}

void QFieldXmlHttpRequest::scheduleAutoDelete()
{
  // Defer so QML callbacks finish first.
  QTimer::singleShot( 0, this, &amp;QObject::deleteLater );
}

bool QFieldXmlHttpRequest::containsNewlines( const QString &amp;stringValue )
{
  return stringValue.contains( QLatin1Char( '\n' ) ) || stringValue.contains( QLatin1Char( '\r' ) );
}

bool QFieldXmlHttpRequest::isOpen() const
{
  return !mMethod.isEmpty() &amp;&amp; mUrl.isValid();
}

QString QFieldXmlHttpRequest::normalizeHeaderName( const QString &amp;stringValue )
{
  return stringValue.trimmed().toLower();
}

void QFieldXmlHttpRequest::collectResponseHeaders( QNetworkReply *networkReply )
{
  if ( !networkReply )
  {
    return;
  }

  const QList&lt;QNetworkReply::RawHeaderPair&gt; &amp;headerPairs = networkReply-&gt;rawHeaderPairs();
  for ( const QNetworkReply::RawHeaderPair &amp;headerPair : headerPairs )
  {
    const QString headerNameLowercase = QString::fromUtf8( headerPair.first ).trimmed().toLower();
    const QString headerValue = QString::fromUtf8( headerPair.second ).trimmed();
    if ( !headerNameLowercase.isEmpty() )
    {
      mResponseHeaders.insert( headerNameLowercase, headerValue );
    }
  }
}

QString QFieldXmlHttpRequest::getResponseHeader( const QString &amp;name ) const
{
  return mResponseHeaders.value( normalizeHeaderName( name ) );
}

QString QFieldXmlHttpRequest::getAllResponseHeaders() const
{
  QString allHeaders;

  QMap&lt;QString, QString&gt;::ConstIterator headerIterator = mResponseHeaders.constBegin();
  for ( ; headerIterator != mResponseHeaders.constEnd(); ++headerIterator )
  {
    allHeaders += headerIterator.key() + QStringLiteral( &quot;: &quot; ) + headerIterator.value() + QStringLiteral( &quot;\r\n&quot; );
  }

  return allHeaders;
}

void QFieldXmlHttpRequest::clearResponse()
{
  mStatus = 0;
  mStatusText.clear();
  mResponse = {};
  mResponseText.clear();
  mResponseType.clear();
  mResponseUrl.clear();

  mResponseHeaders.clear();
  mLastError = QNetworkReply::NoError;
  mLastErrorString.clear();
}

void QFieldXmlHttpRequest::resetForNewRequest()
{
  clearResponse();
  mFinalized = false;
  mTimedOut = false;
  mAborted = false;
}

void QFieldXmlHttpRequest::cleanupReply( bool abortNetwork )
{
  for ( const QMetaObject::Connection &amp;connection : mConnections )
  {
    disconnect( connection );
  }
  mConnections.clear();

  if ( mReply )
  {
    disconnect( mReply, nullptr, this, nullptr );

    if ( abortNetwork )
    {
      mReply-&gt;abort();
    }

    mReply-&gt;deleteLater();
    mReply = nullptr;
  }
}

void QFieldXmlHttpRequest::setReadyState( ReadyState state )
{
  if ( mReadyState == state )
  {
    return;
  }

  mReadyState = state;
  emit readyStateChanged();
  call( mOnReadyStateChanged );
}

void QFieldXmlHttpRequest::open( const QString &amp;method, const QUrl &amp;url )
{
  // open() cancels any in-flight request
  if ( mReply )
  {
    cleanupReply( true );
  }

  const QByteArray methodBytes = method.trimmed().toUtf8();
  if ( methodBytes.isEmpty() || !url.isValid() )
  {
    qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest: invalid open() args:&quot; &lt;&lt; method &lt;&lt; url;
    mMethod.clear();
    mUrl = QUrl();
    mRequest = QNetworkRequest();
    resetForNewRequest();
    setReadyState( Unsent );
    return;
  }

  mMethod = methodBytes;
  mUrl = url;
  mRequest = QNetworkRequest( mUrl );
  mRequest.setAttribute( QNetworkRequest::RedirectPolicyAttribute, QNetworkRequest::NoLessSafeRedirectPolicy );

  resetForNewRequest();
  setReadyState( Opened );
}

void QFieldXmlHttpRequest::setRequestHeader( const QString &amp;headerName, const QString &amp;headerValue )
{
  if ( !isOpen() || mReply )
  {
    return;
  }

  const QString headerKey = headerName.trimmed();
  if ( headerKey.isEmpty() )
  {
    return;
  }

  if ( containsNewlines( headerKey ) || containsNewlines( headerValue ) )
  {
    qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest: blocked header with newline:&quot; &lt;&lt; headerName;
    return;
  }

  const QString headerKeyLower = normalizeHeaderName( headerKey );

  // IMPORTANT: keep Content-Type in the typed header too, because startRequest()
  // reads it via mRequest.header(QNetworkRequest::ContentTypeHeader)
  if ( headerKeyLower == QStringLiteral( &quot;content-type&quot; ) )
  {
    mRequest.setHeader( QNetworkRequest::ContentTypeHeader, headerValue.trimmed() );
    return;
  }

  mRequest.setRawHeader( headerKey.toUtf8(), headerValue.toUtf8() );
}


void QFieldXmlHttpRequest::send( const QVariant &amp;body )
{
  if ( !isOpen() )
  {
    qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest: call open() before send()&quot;;
    return;
  }

  // &quot;Resend&quot; should not behave like abort(): it should not produce an error callback chain
  if ( mReply )
  {
    cleanupReply( true );
  }

  if ( mReadyState != Opened )
  {
    setReadyState( Opened );
  }

  resetForNewRequest();
  ++mRequestSerial;

  startRequest( body );
}

void QFieldXmlHttpRequest::startRequest( const QVariant &amp;body )
{
  const QByteArray upperCaseMethod = mMethod.trimmed().toUpper();

  // Security: only allow http(s) network requests.
  // Do this at send-time to avoid breaking existing open()-&gt;setHeader()-&gt;send() flows.
  const QString urlScheme = mUrl.scheme().toLower();
  if ( urlScheme != QStringLiteral( &quot;http&quot; ) &amp;&amp; urlScheme != QStringLiteral( &quot;https&quot; ) )
  {
    qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest: blocked non-http(s) URL:&quot; &lt;&lt; mUrl;
    finalizeAsError( QStringLiteral( &quot;Blocked non-http(s) URL&quot; ) );
    return;
  }

  const bool isGetMethod = ( upperCaseMethod == &quot;GET&quot; );
  const bool isPostMethod = ( upperCaseMethod == &quot;POST&quot; );
  const bool isPutMethod = ( upperCaseMethod == &quot;PUT&quot; );
  const bool isDeleteMethod = ( upperCaseMethod == &quot;DELETE&quot; );

  if ( !isGetMethod &amp;&amp; !isPostMethod &amp;&amp; !isPutMethod &amp;&amp; !isDeleteMethod )
  {
    qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest: unsupported method:&quot; &lt;&lt; upperCaseMethod;
    finalizeAsError( QStringLiteral( &quot;Unsupported HTTP method&quot; ) );
    return;
  }

  const QString requestContentTypeHeader = mRequest.header( QNetworkRequest::ContentTypeHeader ).toString();
  const bool isMultipartForcedByHeader = requestContentTypeHeader.startsWith( QStringLiteral( &quot;multipart/form-data&quot; ), Qt::CaseInsensitive );

  // Multipart can only be built from a map (see buildMultipart()).
  const bool canBuildMultipart = body.canConvert&lt;QVariantMap&gt;();

  // Only detect file URLs when we can actually build a multipart body.
  const bool bodyHasFileUrls = canBuildMultipart &amp;&amp; bodyContainsFileUrls( body );

  const bool shouldUseMultipart = ( isMultipartForcedByHeader &amp;&amp; canBuildMultipart ) || bodyHasFileUrls;

  // If the caller forces multipart via header but doesn't provide a map body, fail fast with a clear error.
  if ( isMultipartForcedByHeader &amp;&amp; !canBuildMultipart )
  {
    qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest: multipart/form-data requires a QVariantMap body&quot;;
    finalizeAsError( QStringLiteral( &quot;multipart/form-data requires a map body&quot; ) );
    return;
  }

  QNetworkAccessManager *networkAccessManager = QgsNetworkAccessManager::instance();
  if ( !networkAccessManager )
  {
    finalizeAsError( QStringLiteral( &quot;Network manager unavailable&quot; ) );
    return;
  }

  QNetworkReply *networkReply = nullptr;

  if ( isGetMethod )
  {
    networkReply = networkAccessManager-&gt;get( mRequest );
  }
  else if ( isDeleteMethod )
  {
    QString inferredContentTypeHeader;
    QByteArray requestPayload;

    if ( body.isValid() &amp;&amp; !body.isNull() )
    {
      requestPayload = bodyToBytes( body, &amp;inferredContentTypeHeader );
    }

    if ( mRequest.header( QNetworkRequest::ContentTypeHeader ).isNull() &amp;&amp; !inferredContentTypeHeader.isEmpty() )
    {
      mRequest.setHeader( QNetworkRequest::ContentTypeHeader, inferredContentTypeHeader );
    }

    if ( requestPayload.isEmpty() )
    {
      networkReply = networkAccessManager-&gt;deleteResource( mRequest );
    }

    else
    {
      networkReply = networkAccessManager-&gt;sendCustomRequest( mRequest, QByteArrayLiteral( &quot;DELETE&quot; ), requestPayload );
    }
  }
  else
  {
    if ( shouldUseMultipart )
    {
      // Do NOT keep a preset Content-Type, because QHttpMultiPart/QNetworkAccessManager
      // will generate the correct Content-Type including the boundary.
      if ( isMultipartForcedByHeader )
      {
        mRequest.setHeader( QNetworkRequest::ContentTypeHeader, QVariant() );
      }

      QHttpMultiPart *multipartBody = buildMultipart( body );
      if ( !multipartBody )
      {
        finalizeAsError( QStringLiteral( &quot;Invalid multipart body&quot; ) );
        return;
      }

      networkReply = isPostMethod ? networkAccessManager-&gt;post( mRequest, multipartBody )
                                  : networkAccessManager-&gt;put( mRequest, multipartBody );

      if ( networkReply )
      {
        multipartBody-&gt;setParent( networkReply );
      }
      else
      {
        multipartBody-&gt;deleteLater();
      }
    }
    else
    {
      QString inferredContentTypeHeader;
      QByteArray requestPayload;

      if ( body.isValid() &amp;&amp; !body.isNull() )
      {
        requestPayload = bodyToBytes( body, &amp;inferredContentTypeHeader );
      }

      if ( mRequest.header( QNetworkRequest::ContentTypeHeader ).isNull() &amp;&amp; !inferredContentTypeHeader.isEmpty() )
      {
        mRequest.setHeader( QNetworkRequest::ContentTypeHeader, inferredContentTypeHeader );
      }

      networkReply = isPostMethod ? networkAccessManager-&gt;post( mRequest, requestPayload )
                                  : networkAccessManager-&gt;put( mRequest, requestPayload );
    }
  }

  if ( !networkReply )
  {
    finalizeAsError( QStringLiteral( &quot;Failed to start request&quot; ) );
    return;
  }

  mReply = networkReply;
  hookReply( mReply );
}

void QFieldXmlHttpRequest::abort()
{
  if ( mFinalized )
  {
    return;
  }

  if ( !mReply )
  {
    return;
  }

  mAborted = true;

  cleanupReply( true );
  clearResponse();

  setReadyState( Done );
  emit responseChanged();

  call( mOnAborted );
  call( mOnLoadEnd );
  scheduleAutoDelete();
}

void QFieldXmlHttpRequest::hookReply( QNetworkReply *networkReply )
{
  if ( !networkReply )
  {
    return;
  }

  mConnections &lt;&lt; connect( networkReply, &amp;QNetworkReply::metaDataChanged, this, [this, networkReply]() {
    if ( mReadyState &lt; HeadersReceived )
    {
      setReadyState( HeadersReceived );
    }

    collectResponseHeaders( networkReply );
  } );

  mConnections &lt;&lt; connect( networkReply, &amp;QNetworkReply::readyRead, this, [this]() {
    if ( mReadyState &lt; HeadersReceived )
    {
      setReadyState( HeadersReceived );
    }
    if ( mReadyState &lt; Loading )
    {
      setReadyState( Loading );
    }
  } );

  mConnections &lt;&lt; connect( networkReply, &amp;QNetworkReply::downloadProgress, this, [this]( qint64 receivedBytes, qint64 totalBytes ) {
    call( mOnDownloadProgress, { double( receivedBytes ), double( totalBytes ) } );
  } );

  mConnections &lt;&lt; connect( networkReply, &amp;QNetworkReply::uploadProgress, this, [this]( qint64 sentBytes, qint64 totalBytes ) {
    call( mOnUploadProgress, { double( sentBytes ), double( totalBytes ) } );
  } );

  mConnections &lt;&lt; connect( networkReply, &amp;QNetworkReply::redirected, this, [this]( const QUrl &amp;redirectUrl ) {
    call( mOnRedirected, { redirectUrl.toString() } );
  } );

  mConnections &lt;&lt; connect( networkReply, &amp;QNetworkReply::errorOccurred, this, [this]( QNetworkReply::NetworkError networkError ) {
    if ( mFinalized )
    {
      return;
    }

    if ( mAborted )
    {
      return;
    }

    if ( networkError == QNetworkReply::TimeoutError )
    {
      if ( mTimedOut )
      {
        return;
      }

      mTimedOut = true;

      cleanupReply( true );
      clearResponse();

      setReadyState( Done );
      emit responseChanged();

      call( mOnTimeout );
      call( mOnLoadEnd );
      scheduleAutoDelete();
      return;
    }

    if ( networkError == QNetworkReply::OperationCanceledError )
    {
      return;
    }

    mLastError = networkError;
    mLastErrorString = mReply ? mReply-&gt;errorString() : QString();
  } );

  mConnections &lt;&lt; connect( networkReply, &amp;QNetworkReply::finished, this, [this, networkReply]() {
    finalizeReply( networkReply );
  } );

  if ( mTimeoutMs &gt; 0 )
  {
    const quint64 requestSerialSnapshot = mRequestSerial;
    QTimer::singleShot( mTimeoutMs, this, [this, requestSerialSnapshot]() {
      if ( requestSerialSnapshot != mRequestSerial )
      {
        return;
      }

      if ( mFinalized || mAborted || mTimedOut )
      {
        return;
      }

      if ( !mReply || mReply-&gt;isFinished() )
      {
        return;
      }

      mTimedOut = true;

      cleanupReply( true );
      clearResponse();

      setReadyState( Done );
      emit responseChanged();

      call( mOnTimeout );
      call( mOnLoadEnd );
      scheduleAutoDelete();
    } );
  }
}

void QFieldXmlHttpRequest::finalizeReply( QNetworkReply *finishedReply )
{
  if ( mFinalized )
  {
    return;
  }

  // Ignore stale finished signals (example; resend raced with previous reply)
  if ( !finishedReply || finishedReply != mReply )
  {
    return;
  }

  mFinalized = true;

  mStatus = mReply-&gt;attribute( QNetworkRequest::HttpStatusCodeAttribute ).toInt();
  mStatusText = mReply-&gt;attribute( QNetworkRequest::HttpReasonPhraseAttribute ).toString();

  mResponseUrl = mReply-&gt;url();
  mResponseType = mReply-&gt;header( QNetworkRequest::ContentTypeHeader ).toString();

  collectResponseHeaders( mReply );

  const QByteArray responseBytes = mReply-&gt;readAll();
  mResponseText = QString::fromUtf8( responseBytes );

  const QString responseContentTypeLowercase = mResponseType.toLower();
  if ( responseContentTypeLowercase.contains( QStringLiteral( &quot;application/json&quot; ) ) || responseContentTypeLowercase.contains( QStringLiteral( &quot;+json&quot; ) ) )
  {
    QJsonParseError jsonParseError;
    const QJsonDocument jsonDocument = QJsonDocument::fromJson( responseBytes, &amp;jsonParseError );
    if ( jsonParseError.error == QJsonParseError::NoError )
    {
      if ( jsonDocument.isObject() )
      {
        mResponse = jsonDocument.object().toVariantMap();
      }
      else if ( jsonDocument.isArray() )
      {
        mResponse = jsonDocument.array().toVariantList();
      }
      else
      {
        mResponse = mResponseText;
      }
    }
    else
    {
      mResponse = mResponseText;
    }
  }
  else
  {
    mResponse = mResponseText;
  }

  cleanupReply( false );

  setReadyState( Done );
  emit responseChanged();

  if ( mStatus == 0 )
  {
    const int errorCode = ( mLastError != QNetworkReply::NoError ) ? int( mLastError ) : int( QNetworkReply::UnknownNetworkError );
    const QString errorMessage = !mLastErrorString.isEmpty() ? mLastErrorString : QStringLiteral( &quot;Network error&quot; );
    call( mOnError, { errorCode, errorMessage } );
  }
  else
  {
    call( mOnLoad );
  }

  call( mOnLoadEnd );
  scheduleAutoDelete();
}

void QFieldXmlHttpRequest::finalizeAsError( const QString &amp;detail, bool shouldEmitResponseChanged )
{
  if ( mFinalized )
  {
    return;
  }

  clearResponse();

  const QJsonObject errorObj { { QStringLiteral( &quot;detail&quot; ), detail } };
  mResponseText = QString::fromUtf8( QJsonDocument( errorObj ).toJson( QJsonDocument::Compact ) );
  mResponse = errorObj.toVariantMap();

  mLastError = QNetworkReply::UnknownNetworkError;
  mLastErrorString = detail;

  mFinalized = true;

  cleanupReply( false );

  setReadyState( Done );
  if ( shouldEmitResponseChanged )
  {
    emit responseChanged();
  }

  call( mOnError, { int( QNetworkReply::UnknownNetworkError ), detail } );
  call( mOnLoadEnd );
  scheduleAutoDelete();
}

QByteArray QFieldXmlHttpRequest::bodyToBytes( const QVariant &amp;body, QString *outContentType ) const
{
  if ( outContentType )
  {
    outContentType-&gt;clear();
  }

  if ( body.typeId() == QMetaType::QByteArray )
  {
    return body.toByteArray();
  }

  if ( body.typeId() == QMetaType::QString )
  {
    if ( outContentType )
    {
      *outContentType = QStringLiteral( &quot;text/plain; charset=utf-8&quot; );
    }
    return body.toString().toUtf8();
  }

  const QJsonValue jsonValue = QJsonValue::fromVariant( body );
  QJsonDocument jsonDocument = jsonValue.isObject()  ? QJsonDocument( jsonValue.toObject() )
                               : jsonValue.isArray() ? QJsonDocument( jsonValue.toArray() )
                                                     : QJsonDocument( QJsonObject { { QStringLiteral( &quot;value&quot; ), jsonValue } } );

  if ( outContentType )
  {
    *outContentType = QStringLiteral( &quot;application/json&quot; );
  }

  return jsonDocument.toJson( QJsonDocument::Compact );
}

bool QFieldXmlHttpRequest::bodyContainsFileUrls( const QVariant &amp;body ) const
{
  if ( body.typeId() == QMetaType::QString )
  {
    return isFileUrlString( body.toString() );
  }

  if ( body.canConvert&lt;QVariantList&gt;() )
  {
    const QVariantList variantList = body.toList();
    return std::any_of( variantList.cbegin(), variantList.cend(), []( const QVariant &amp;listValue ) {
      return listValue.typeId() == QMetaType::QString &amp;&amp; isFileUrlString( listValue.toString() );
    } );
  }

  if ( body.canConvert&lt;QVariantMap&gt;() )
  {
    const QVariantMap variantMap = body.toMap();
    return std::any_of( variantMap.cbegin(), variantMap.cend(), []( const QVariant &amp;mapValue ) {
      if ( mapValue.typeId() == QMetaType::QString &amp;&amp; isFileUrlString( mapValue.toString() ) )
      {
        return true;
      }

      if ( mapValue.canConvert&lt;QVariantList&gt;() )
      {
        const QVariantList nestedVariantList = mapValue.toList();
        return std::any_of( nestedVariantList.cbegin(), nestedVariantList.cend(), []( const QVariant &amp;nestedListValue ) {
          return nestedListValue.typeId() == QMetaType::QString &amp;&amp; isFileUrlString( nestedListValue.toString() );
        } );
      }
      return false;
    } );
  }

  return false;
}

bool QFieldXmlHttpRequest::isAllowedLocalUploadPath( const QString &amp;localPath ) const
{
  if ( localPath.isEmpty() )
  {
    return false;
  }

  const QString canonical = QFileInfo( localPath ).canonicalFilePath();
  if ( canonical.isEmpty() )
  {
    return false;
  }

  if ( FileUtils::isWithinProjectDirectory( canonical ) )
  {
    return true;
  }

  const QString cloudRoot = QFieldCloudUtils::localCloudDirectory();
  if ( !cloudRoot.isEmpty() )
  {
    const QString cloudCanonical = QFileInfo( cloudRoot ).canonicalFilePath();
    if ( !cloudCanonical.isEmpty() )
    {
      const QString cloudRootPrefix = QDir::cleanPath( cloudCanonical ) + QDir::separator();
      if ( QDir::cleanPath( canonical ).startsWith( cloudRootPrefix ) )
      {
        return true;
      }
    }
  }

  return false;
}

QHttpMultiPart *QFieldXmlHttpRequest::buildMultipart( const QVariant &amp;body ) const
{
  if ( !body.canConvert&lt;QVariantMap&gt;() )
  {
    return nullptr;
  }

  const QVariantMap bodyMap = body.toMap();
  QHttpMultiPart *multipartBody = new QHttpMultiPart( QHttpMultiPart::FormDataType );

  const auto appendTextPart = [multipartBody]( const QString &amp;fieldName, const QString &amp;fieldValueText ) {
    if ( fieldName.isEmpty() )
    {
      return;
    }

    QHttpPart httpPart;
    httpPart.setHeader( QNetworkRequest::ContentDispositionHeader,
                        QStringLiteral( &quot;form-data; name=\&quot;%1\&quot;&quot; ).arg( fieldName ) );
    httpPart.setBody( fieldValueText.toUtf8() );
    multipartBody-&gt;append( httpPart );
  };

  const auto appendFilePart = [this, multipartBody]( const QString &amp;fieldName, const QUrl &amp;fileUrl ) -&gt; bool {
    if ( fieldName.isEmpty() || !fileUrl.isValid() || !fileUrl.isLocalFile() )
    {
      return false;
    }

    const QString filePath = fileUrl.toLocalFile();
    if ( !isAllowedLocalUploadPath( filePath ) )
    {
      qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest: blocked file upload path:&quot; &lt;&lt; filePath;
      return false;
    }

    QFile *fileDevice = new QFile( filePath );
    if ( !fileDevice-&gt;exists() || !fileDevice-&gt;open( QFile::ReadOnly ) )
    {
      qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest: cannot open file:&quot; &lt;&lt; filePath;
      delete fileDevice;
      return false;
    }

    const QString mimeTypeName = FileUtils::mimeTypeName( filePath );

    QHttpPart httpPart;
    httpPart.setHeader( QNetworkRequest::ContentTypeHeader, mimeTypeName );
    httpPart.setHeader( QNetworkRequest::ContentDispositionHeader,
                        QStringLiteral( &quot;form-data; name=\&quot;%1\&quot;; filename=\&quot;%2\&quot;&quot; )
                          .arg( fieldName, QFileInfo( filePath ).fileName() ) );
    httpPart.setBodyDevice( fileDevice );

    fileDevice-&gt;setParent( multipartBody );
    multipartBody-&gt;append( httpPart );
    return true;
  };

  QVariantMap::ConstIterator fieldIterator = bodyMap.constBegin();
  for ( ; fieldIterator != bodyMap.constEnd(); ++fieldIterator )
  {
    const QString &amp;fieldName = fieldIterator.key();
    const QVariant &amp;fieldValue = fieldIterator.value();

    if ( fieldValue.canConvert&lt;QVariantList&gt;() )
    {
      const QVariantList listValues = fieldValue.toList();
      for ( const QVariant &amp;listValue : listValues )
      {
        if ( listValue.typeId() == QMetaType::QString )
        {
          const QString stringValue = listValue.toString();
          if ( isFileUrlString( stringValue ) )
          {
            const QUrl fileUrl = UrlUtils::fromString( stringValue );
            if ( fileUrl.isLocalFile() &amp;&amp; appendFilePart( fieldName, fileUrl ) )
            {
              continue;
            }
          }
        }
        const QJsonValue value = QJsonValue::fromVariant( listValue );
        if ( value.isObject() || value.isArray() )
        {
          const QJsonDocument document = value.isObject() ? QJsonDocument( value.toObject() ) : QJsonDocument( value.toArray() );
          appendTextPart( fieldName, QString::fromUtf8( document.toJson( QJsonDocument::Compact ) ) );
        }
        else
        {
          appendTextPart( fieldName, value.toVariant().toString() );
        }
      }
      continue;
    }

    if ( fieldValue.typeId() == QMetaType::QString )
    {
      const QString stringValue = fieldValue.toString();
      if ( isFileUrlString( stringValue ) )
      {
        const QUrl fileUrl = UrlUtils::fromString( stringValue );
        if ( appendFilePart( fieldName, fileUrl ) )
        {
          continue;
        }
      }
    }

    const QJsonValue jsonValue = QJsonValue::fromVariant( fieldValue );
    if ( jsonValue.isObject() || jsonValue.isArray() )
    {
      const QJsonDocument jsonDocument = jsonValue.isObject() ? QJsonDocument( jsonValue.toObject() ) : QJsonDocument( jsonValue.toArray() );
      appendTextPart( fieldName, QString::fromUtf8( jsonDocument.toJson( QJsonDocument::Compact ) ) );
      continue;
    }

    appendTextPart( fieldName, jsonValue.toVariant().toString() );
  }

  return multipartBody;
}

void QFieldXmlHttpRequest::call( const QJSValue &amp;callback, const QJSValueList &amp;arguments )
{
  if ( !callback.isCallable() )
  {
    return;
  }

  const QJSValue result = callback.call( arguments );
  if ( result.isError() )
  {
    qWarning() &lt;&lt; &quot;QFieldXmlHttpRequest callback error:&quot;
               &lt;&lt; result.property( &quot;fileName&quot; ).toString()
               &lt;&lt; result.property( &quot;lineNumber&quot; ).toInt()
               &lt;&lt; result.toString();
  }
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 <a href="https://OPENGIS.ch">OPENGIS.ch</a> -  <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC-BY-SA 4.0</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>