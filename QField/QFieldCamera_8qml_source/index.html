
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.3">
    
    
      
        <title>File QFieldCamera.qml - QField API Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#file-qfieldcameraqml" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="QField API Documentation" class="md-header__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            QField API Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              File QFieldCamera.qml
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.768 3.96zl-.002-.005a9 9 0 0 0-.218-.779c-.13-.394.21-.8.602-.67q.435.144.855.328l.01.005A10.002 10.002 0 0 1 12 22a10 10 0 0 1-9.162-5.985l-.004-.01a10 10 0 0 1-.329-.855c-.13-.392.277-.732.67-.602q.386.126.78.218l.004.002A9 9 0 0 0 14.999 6a9 9 0 0 0-.231-2.04M16.5 6c0 5.799-4.701 10.5-10.5 10.5q-.64 0-1.26-.075A8.5 8.5 0 1 0 16.425 4.74q.075.62.075 1.259Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 19a7 7 0 1 1 0-14 7 7 0 0 1 0 14m0-1.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 1 0 0 11m-5.657.157a.75.75 0 0 1 0 1.06l-1.768 1.768a.749.749 0 0 1-1.275-.326.75.75 0 0 1 .215-.734l1.767-1.768a.75.75 0 0 1 1.061 0M3.515 3.515a.75.75 0 0 1 1.06 0l1.768 1.768a.749.749 0 0 1-.326 1.275.75.75 0 0 1-.734-.215L3.515 4.575a.75.75 0 0 1 0-1.06M12 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 12 0M4 12a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 12m8 8a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 12 20m12-8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 24 12m-6.343 5.657a.75.75 0 0 1 1.06 0l1.768 1.768a.75.75 0 0 1-.018 1.042.75.75 0 0 1-1.042.018l-1.768-1.767a.75.75 0 0 1 0-1.061m2.828-14.142a.75.75 0 0 1 0 1.06l-1.768 1.768a.75.75 0 0 1-1.042-.018.75.75 0 0 1-.018-1.042l1.767-1.768a.75.75 0 0 1 1.061 0"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="QField API Documentation" class="md-nav__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    QField API Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../snippets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Code Snippets
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__core/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    C++ Classes
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__qml/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    QML Items
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="file-qfieldcameraqml">File QFieldCamera.qml</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_1d81f7f4362e4398c0a695c4e466fcb0/"><strong>qml</strong></a> <strong>&gt;</strong> <a href="../QFieldCamera_8qml/"><strong>QFieldCamera.qml</strong></a></p>
<p><a href="../QFieldCamera_8qml/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">import QtQuick
import QtQuick.Controls
import QtQuick.Shapes
import QtQuick.Window
import QtMultimedia
import QtCore
import org.qfield
import Theme

Popup {
  id: cameraItem
  z: 10000 // 1000s are embedded feature forms, use a higher value to insure feature form popups always show above embedded feature forms

  property bool isCapturing: state == &quot;PhotoCapture&quot; || state == &quot;VideoCapture&quot;
  property bool isPortraitMode: mainWindow.height &gt; mainWindow.width

  property string currentPath: ''
  property var currentPosition: PositioningUtils.createEmptyGnssPositionInformation()
  property var currentProjectedPosition: undefined

  property bool captureLoaderActivated: false

  function requiredPermissionsGranted() {
    if (cameraPermission.status !== Qt.PermissionStatus.Granted) {
      return false;
    }
    if (state === &quot;VideoCapture&quot; &amp;&amp; microphonePermission.status !== Qt.PermissionStatus.Granted) {
      return false;
    }
    return true;
  }

  function tryActivateCaptureLoader() {
    if (!captureLoaderActivated &amp;&amp; requiredPermissionsGranted()) {
      captureLoaderActivated = true;
    }
  }

  signal finished(string path)
  signal canceled

  x: 0
  y: 0
  width: mainWindow.width
  height: mainWindow.height
  padding: 0

  parent: mainWindow.contentItem
  modal: true
  focus: true

  property string state: &quot;PhotoCapture&quot;
  onStateChanged: {
    if (state == &quot;PhotoCapture&quot;) {
      photoPreview.source = '';
      videoPreview.source = '';
    } else if (state == &quot;VideoCapture&quot;) {
      photoPreview.source = '';
      videoPreview.source = '';
    }
  }

  onAboutToShow: {
    currentPath = &quot;&quot;;
    photoPreview.source = &quot;&quot;;
    videoPreview.stop();
    videoPreview.source = &quot;&quot;;

    captureLoaderActivated = false;

    if (cameraPermission.status === Qt.PermissionStatus.Undetermined) {
      cameraPermission.request();
    } else if (state == &quot;VideoCapture&quot; &amp;&amp; microphonePermission.status === Qt.PermissionStatus.Undetermined) {
      microphonePermission.request();
    }

    tryActivateCaptureLoader();
  }

  onAboutToHide: {
    captureLoaderActivated = false;
  }

  QfCameraPermission {
    id: cameraPermission

    onStatusChanged: {
      if (state == &quot;VideoCapture&quot; &amp;&amp; microphonePermission.status === Qt.PermissionStatus.Undetermined) {
        microphonePermission.request();
      }
      cameraItem.tryActivateCaptureLoader();
    }
  }
  QfMicrophonePermission {
    id: microphonePermission

    onStatusChanged: {
      if (cameraPermission.status === Qt.PermissionStatus.Undetermined) {
        cameraPermission.request();
      }
      cameraItem.tryActivateCaptureLoader();
    }
  }

  Settings {
    id: cameraSettings
    property bool stamping: false
    property bool geoTagging: true
    property bool showGrid: false
    property string deviceId: ''
    property size resolution: Qt.size(0, 0)
    property int pixelFormat: 0
  }

  ExpressionEvaluator {
    id: stampExpressionEvaluator

    property string defaultTextTemplate: &quot;[% format_date(now(), 'yyyy-MM-dd @ HH:mm') || if(@gnss_coordinate is not null, format('\n&quot; + qsTr(&quot;Latitude&quot;) + &quot; %1 | &quot; + qsTr(&quot;Longitude&quot;) + &quot; %2 | &quot; + qsTr(&quot;Altitude&quot;) + &quot; %3\n&quot; + qsTr(&quot;Speed&quot;) + &quot; %4 | &quot; + qsTr(&quot;Orientation&quot;) + &quot; %5', coalesce(format_number(y(@gnss_coordinate), 7), 'N/A'), coalesce(format_number(x(@gnss_coordinate), 7), 'N/A'), coalesce(format_number(@corrected_elevation, 3) || ' ' || @corrected_elevation_unit, 'N/A'), if(@gnss_ground_speed != 'nan', format_number(@gnss_ground_speed, 3) || ' m/s', 'N/A'), if(@gnss_orientation != 'nan', format_number(@gnss_orientation, 1) || ' °', 'N/A')), '') %]&quot;

    mode: ExpressionEvaluator.ExpressionTemplateMode
    expressionText: &quot;&quot;

    project: qgisProject
    appExpressionContextScopesGenerator: AppExpressionContextScopesGenerator {
      positionInformation: currentPosition
      cloudUserInformation: appScopesGenerator.cloudUserInformation
    }

    variables: {
      &quot;corrected_elevation&quot;: currentProjectedPosition ? currentProjectedPosition.z : currentPosition.altitude,
      &quot;corrected_elevation_unit&quot;: UnitTypes.toAbbreviatedString(positionSource.coordinateTransformer.destinationCrs.mapUnit)
    }
  }

  Page {
    width: parent.width
    height: parent.height
    padding: 0

    background: Rectangle {
      anchors.fill: parent
      color: &quot;#000000&quot;
    }

    MediaDevices {
      id: mediaDevices
    }

    Loader {
      id: captureLoader
      anchors.fill: parent

      active: cameraItem.visible &amp;&amp; captureLoaderActivated
      asynchronous: true

      sourceComponent: Component {
        Item {
          anchors.fill: parent

          property alias captureSession: captureSession
          property alias camera: camera
          property alias imageCapture: imageCapture
          property alias recorder: recorder
          property alias videoOutput: videoOutput   // expose it

          VideoOutput {
            id: videoOutput
            anchors.fill: parent
            visible: cameraItem.state == &quot;PhotoCapture&quot; || cameraItem.state == &quot;VideoCapture&quot;
          }

          CaptureSession {
            id: captureSession

            camera: Camera {
              id: camera
              property bool restarting: false
              active: cameraItem.visible &amp;&amp; cameraPermission.status === Qt.PermissionStatus.Granted &amp;&amp; !restarting

              function applyCameraFormat() {
                if (cameraSettings.pixelFormat != 0) {
                  let fallbackIndex = -1;
                  let i = 0;
                  for (let format of camera.cameraDevice.videoFormats) {
                    if (format.resolution === cameraSettings.resolution &amp;&amp; format.pixelFormat === cameraSettings.pixelFormat) {
                      camera.cameraFormat = format;
                      fallbackIndex = -1;
                      break;
                    } else if (format.resolution === cameraSettings.resolution) {
                      // If we can't match the pixel format and resolution, go for resolution match across devices
                      fallbackIndex = i;
                    }
                    i++;
                  }
                  if (fallbackIndex &gt;= 0) {
                    camera.cameraFormat = camera.cameraDevice.videoFormats[fallbackIndex];
                  }
                }
              }

              function zoomIn(increase) {
                var zoom = camera.zoomFactor + increase;
                if (zoom &lt; camera.maximumZoomFactor) {
                  camera.zoomFactor = zoom;
                } else {
                  camera.zoomFactor = camera.maximumZoomFactor;
                }
              }

              function zoomOut(decrease) {
                var zoom = camera.zoomFactor - decrease;
                if (zoom &gt; 1) {
                  camera.zoomFactor = zoom;
                } else {
                  camera.zoomFactor = 1;
                }
              }
            }

            videoOutput: videoOutput
            imageCapture: ImageCapture {
              id: imageCapture

              onImageSaved: (requestId, path) =&gt; {
                currentPath = path;
              }

              onPreviewChanged: {
                cameraItem.state = &quot;PhotoPreview&quot;;
                photoPreview.source = &quot;&quot;;
                Qt.callLater(() =&gt; photoPreview.source = imageCapture.preview);
              }
            }

            recorder: MediaRecorder {
              id: recorder

              onRecorderStateChanged: {
                if (cameraItem.state == &quot;VideoPreview&quot; &amp;&amp; recorderState === MediaRecorder.StoppedState) {
                  videoPreview.source = recorder.actualLocation;
                  videoPreview.play();
                }
              }
            }
          }
        }
      }

      onLoaded: {
        item.recorder.mediaFormat.audioCodec = MediaFormat.AudioCodec.AAC;
        item.recorder.mediaFormat.videoCodec = MediaFormat.VideoCodec.H264;
        item.recorder.mediaFormat.fileFormat = MediaFormat.MPEG4;
        let cameraPicked = false;
        if (cameraSettings.deviceId != '') {
          for (const device of mediaDevices.videoInputs) {
            if (device.id === cameraSettings.deviceId) {
              item.camera.cameraDevice = device;
              cameraPicked = true;
            }
          }
        }
        if (!cameraPicked) {
          item.camera.cameraDevice = mediaDevices.defaultVideoInput;
        }
        item.camera.applyCameraFormat();
      }
    }

    Shape {
      id: grid
      visible: cameraSettings.showGrid
      anchors.centerIn: parent

      property bool readyForGrid: captureLoader.status === Loader.Ready &amp;&amp; captureLoader.item &amp;&amp; captureLoader.item.videoOutput.contentRect.height &gt; 0 &amp;&amp; captureLoader.item.videoOutput.contentRect.width &gt; 0
      property bool isLandscape: readyForGrid ? (mainWindow.width / mainWindow.height) &gt; (captureLoader.item.videoOutput.contentRect.width / captureLoader.item.videoOutput.contentRect.height) : true

      width: readyForGrid ? (isLandscape ? captureLoader.item.videoOutput.contentRect.width * mainWindow.height / captureLoader.item.videoOutput.contentRect.height : mainWindow.width) : mainWindow.width
      height: readyForGrid ? (isLandscape ? mainWindow.height : captureLoader.item.videoOutput.contentRect.height * mainWindow.width / captureLoader.item.videoOutput.contentRect.width) : mainWindow.height

      ShapePath {
        strokeColor: &quot;#99000000&quot;
        strokeWidth: 3
        fillColor: &quot;transparent&quot;

        startX: grid.width / 3
        startY: 0

        PathLine {
          x: grid.width / 3
          y: grid.height
        }
        PathMove {
          x: grid.width / 3 * 2
          y: 0
        }
        PathLine {
          x: grid.width / 3 * 2
          y: grid.height
        }
        PathMove {
          x: 0
          y: grid.height / 3
        }
        PathLine {
          x: grid.width
          y: grid.height / 3
        }
        PathMove {
          x: 0
          y: grid.height / 3 * 2
        }
        PathLine {
          x: grid.width
          y: grid.height / 3 * 2
        }
      }

      ShapePath {
        strokeColor: &quot;#AAFFFFFF&quot;
        strokeWidth: 1
        fillColor: &quot;transparent&quot;

        startX: grid.width / 3
        startY: 0

        PathLine {
          x: grid.width / 3
          y: grid.height
        }
        PathMove {
          x: grid.width / 3 * 2
          y: 0
        }
        PathLine {
          x: grid.width / 3 * 2
          y: grid.height
        }
        PathMove {
          x: 0
          y: grid.height / 3
        }
        PathLine {
          x: grid.width
          y: grid.height / 3
        }
        PathMove {
          x: 0
          y: grid.height / 3 * 2
        }
        PathLine {
          x: grid.width
          y: grid.height / 3 * 2
        }
      }
    }

    Video {
      id: videoPreview
      anchors.fill: parent
      visible: cameraItem.state == &quot;VideoPreview&quot;

      loops: MediaPlayer.Infinite
      muted: true
    }

    Image {
      id: photoPreview

      visible: cameraItem.state == &quot;PhotoPreview&quot;

      anchors.fill: parent
      cache: false
      fillMode: Image.PreserveAspectFit
      smooth: true
      focus: visible
    }

    PinchArea {
      id: pinchArea
      enabled: cameraItem.visible &amp;&amp; cameraItem.isCapturing &amp;&amp; captureLoader.item
      anchors.fill: parent

      onPinchUpdated: pinch =&gt; {
        if (pinch.scale &gt; pinch.previousScale) {
          captureLoader.item.camera.zoomIn(0.05);
        } else {
          captureLoader.item.camera.zoomOut(0.05);
        }
      }
    }

    WheelHandler {
      enabled: cameraItem.visible &amp;&amp; cameraItem.isCapturing &amp;&amp; captureLoader.item
      target: null
      grabPermissions: PointerHandler.CanTakeOverFromHandlersOfDifferentType | PointerHandler.ApprovesTakeOverByItems

      onWheel: event =&gt; {
        if (event.angleDelta.y &gt; 0) {
          captureLoader.item.camera.zoomIn(0.25);
        } else {
          captureLoader.item.camera.zoomOut(0.25);
        }
      }
    }

    Rectangle {
      id: captureFlash
      anchors.fill: parent
      anchors.margins: 6

      color: &quot;transparent&quot;
      SequentialAnimation {
        id: captureFlashAnimation
        PropertyAnimation {
          target: captureFlash
          property: &quot;color&quot;
          to: &quot;white&quot;
          duration: 0
        }
        PropertyAnimation {
          target: captureFlash
          property: &quot;color&quot;
          to: &quot;transparent&quot;
          duration: 1000
        }
      }
    }

    Rectangle {
      width: cameraItem.isPortraitMode ? parent.width : 100 + mainWindow.sceneBottomMargin
      height: cameraItem.isPortraitMode ? 100 + mainWindow.sceneRightMargin : parent.height
      x: cameraItem.isPortraitMode ? 0 : parent.width - width
      y: cameraItem.isPortraitMode ? parent.height - height : 0

      color: Theme.darkGraySemiOpaque

      Rectangle {
        width: cameraItem.isPortraitMode ? parent.width : 100 + mainWindow.sceneBottomMargin
        height: cameraItem.isPortraitMode ? 100 + mainWindow.sceneRightMargin : parent.height
        x: cameraItem.isPortraitMode ? 0 : parent.width - width
        y: cameraItem.isPortraitMode ? parent.height - height : 0

        color: Theme.darkGraySemiOpaque

        Rectangle {
          anchors.top: parent.top
          width: cameraItem.isPortraitMode ? parent.width : parent.width - mainWindow.sceneRightMargin
          height: cameraItem.isPortraitMode ? parent.height - mainWindow.sceneBottomMargin : parent.height
          color: &quot;transparent&quot;

          Rectangle {
            id: captureRing
            anchors.centerIn: parent
            width: 64
            height: 64
            radius: 32
            color: Theme.darkGraySemiOpaque
            border.color: cameraItem.state == &quot;VideoCapture&quot; &amp;&amp; captureLoader.item &amp;&amp; captureLoader.item.recorder.recorderState !== MediaRecorder.StoppedState ? &quot;red&quot; : &quot;white&quot;
            border.width: 2

            QfToolButton {
              id: captureButton

              anchors.centerIn: parent
              visible: captureLoader.status == Loader.Ready &amp;&amp; captureLoader.item

              round: true
              roundborder: true
              iconSource: cameraItem.state == &quot;PhotoPreview&quot; || cameraItem.state == &quot;VideoPreview&quot; ? Theme.getThemeVectorIcon(&quot;ic_check_white_24dp&quot;) : ''
              iconColor: Theme.toolButtonColor
              bgcolor: cameraItem.state == &quot;PhotoPreview&quot; || cameraItem.state == &quot;VideoPreview&quot; ? Theme.mainColor : cameraItem.state == &quot;VideoCapture&quot; ? &quot;red&quot; : &quot;white&quot;

              onClicked: {
                if (!captureLoader.item)
                  return;
                if (cameraItem.state == &quot;PhotoCapture&quot;) {
                  platformUtilities.createDir(qgisProject.homePath, 'DCIM');
                  captureLoader.item.imageCapture.captureToFile(qgisProject.homePath + '/DCIM/');
                  captureFlashAnimation.start();
                  if (positionSource.active) {
                    currentPosition = positionSource.positionInformation;
                    currentProjectedPosition = positionSource.projectedPosition;
                  } else {
                    currentPosition = PositioningUtils.createEmptyGnssPositionInformation();
                    currentProjectedPosition = undefined;
                  }
                } else if (cameraItem.state == &quot;VideoCapture&quot;) {
                  if (captureLoader.item.recorder.recorderState === MediaRecorder.StoppedState) {
                    captureLoader.item.recorder.record();
                  } else {
                    cameraItem.state = &quot;VideoPreview&quot;;
                    captureLoader.item.recorder.stop();
                    const path = captureLoader.item.recorder.actualLocation.toString();
                    currentPath = UrlUtils.toLocalFile(path);
                  }
                } else if (cameraItem.state == &quot;PhotoPreview&quot; || cameraItem.state == &quot;VideoPreview&quot;) {
                  if (!currentPath || currentPath === &quot;&quot;)
                    return;
                  if (cameraItem.state == &quot;PhotoPreview&quot;) {
                    if (cameraSettings.geoTagging &amp;&amp; positionSource.active) {
                      FileUtils.addImageMetadata(currentPath, currentPosition);
                    }
                    if (cameraSettings.stamping || iface.readProjectBoolEntry(&quot;qfieldsync&quot;, &quot;forceStamping&quot;)) {
                      stampExpressionEvaluator.expressionText = iface.readProjectEntry(&quot;qfieldsync&quot;, &quot;stampingDetailsTemplate&quot;, stampExpressionEvaluator.defaultTextTemplate);
                      if (stampExpressionEvaluator.expressionText === &quot;&quot;) {
                        stampExpressionEvaluator.expressionText = stampExpressionEvaluator.defaultTextTemplate;
                      }
                      FileUtils.addImageStamp(currentPath, stampExpressionEvaluator.evaluate(), iface.readProjectEntry(&quot;qfieldsync&quot;, &quot;stampingFontStyle&quot;), iface.readProjectNumEntry(&quot;qfieldsync&quot;, &quot;stampingHorizontalAlignment&quot;, 0), iface.readProjectEntry(&quot;qfieldsync&quot;, &quot;stampingImageDecoration&quot;));
                    }
                  }
                  cameraItem.finished(currentPath);
                }
              }
            }
          }

          QfToolButton {
            id: zoomButton
            visible: cameraItem.isCapturing &amp;&amp; captureLoader.item &amp;&amp; (captureLoader.item.camera.maximumZoomFactor !== 1.0 || captureLoader.item.camera.minimumZoomFactor !== 1.0)

            x: cameraItem.isPortraitMode ? (parent.width / 4) - (width / 2) : (parent.width - width) / 2
            y: cameraItem.isPortraitMode ? (parent.height - height) / 2 : (parent.height / 4) * 3 - (height / 2)

            iconColor: Theme.toolButtonColor
            bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
            round: true

            text: captureLoader.item ? captureLoader.item.camera.zoomFactor.toFixed(1) + 'X' : '1.0X'
            font: Theme.tinyFont

            onClicked: {
              if (captureLoader.item) {
                captureLoader.item.camera.zoomFactor = 1;
              }
            }
          }

          QfToolButton {
            id: flashButton
            visible: cameraItem.isCapturing &amp;&amp; captureLoader.item &amp;&amp; captureLoader.item.camera.isFlashModeSupported(Camera.FlashOn)

            x: cameraItem.isPortraitMode ? (parent.width / 4) * 3 - (width / 2) : (parent.width - width) / 2
            y: cameraItem.isPortraitMode ? (parent.height - height) / 2 : (parent.height / 4) - (height / 2)

            iconSource: {
              if (!captureLoader.item)
                return '';
              switch (captureLoader.item.camera.flashMode) {
              case Camera.FlashAuto:
                return Theme.getThemeVectorIcon('ic_flash_auto_black_24dp');
              case Camera.FlashOn:
                return Theme.getThemeVectorIcon('ic_flash_on_black_24dp');
              case Camera.FlashOff:
                return Theme.getThemeVectorIcon('ic_flash_off_black_24dp');
              default:
                return '';
              }
            }
            iconColor: Theme.toolButtonColor
            bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
            round: true

            onClicked: {
              if (!captureLoader.item)
                return;
              if (captureLoader.item.camera.flashMode === Camera.FlashOff) {
                captureLoader.item.camera.flashMode = Camera.FlashOn;
              } else {
                captureLoader.item.camera.flashMode = Camera.FlashOff;
              }
            }
          }

          Rectangle {
            visible: cameraItem.state == &quot;VideoCapture&quot; &amp;&amp; captureLoader.item &amp;&amp; captureLoader.item.recorder.recorderState !== MediaRecorder.StoppedState

            x: cameraItem.isPortraitMode ? captureRing.x + captureRing.width / 2 - width / 2 : captureRing.x + captureRing.width / 2 - width / 2
            y: cameraItem.isPortraitMode ? captureRing.y - height - 20 : captureRing.y - height - 20

            width: durationLabelMetrics.boundingRect('00:00:00').width + 20
            height: durationLabelMetrics.boundingRect('00:00:00').height + 10
            radius: 6

            color: 'red'

            Text {
              id: durationLabel
              anchors.centerIn: parent
              text: {
                if (captureLoader.item &amp;&amp; captureLoader.item.recorder.duration &gt; 0) {
                  var seconds = Math.ceil(captureLoader.item.recorder.duration / 1000);
                  var hours = Math.floor(seconds / 60 / 60) + '';
                  seconds -= hours * 60 * 60;
                  var minutes = Math.floor(seconds / 60) + '';
                  seconds = (seconds - minutes * 60) + '';
                  return hours.padStart(2, '0') + ':' + minutes.padStart(2, '0') + ':' + seconds.padStart(2, '0');
                } else {
                  // tiny bit of a cheat here as the first second isn't triggered
                  return '00:00:01';
                }
              }
              color: &quot;white&quot;
            }

            FontMetrics {
              id: durationLabelMetrics
              font: durationLabel.font
            }
          }
        }
      }
    }

    QfToolButton {
      id: backButton

      anchors.left: parent.left
      anchors.leftMargin: mainWindow.sceneLeftMargin + 4
      anchors.top: parent.top
      anchors.topMargin: mainWindow.sceneTopMargin + 4

      iconSource: Theme.getThemeVectorIcon(&quot;ic_chevron_left_white_24dp&quot;)
      iconColor: Theme.toolButtonColor
      bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
      round: true

      onClicked: {
        if (cameraItem.state == &quot;PhotoPreview&quot;) {
          cameraItem.state = &quot;PhotoCapture&quot;;
        } else if (cameraItem.state == &quot;VideoPreview&quot;) {
          videoPreview.stop();
          cameraItem.state = &quot;VideoCapture&quot;;
        } else {
          if (currentPath != '') {
            platformUtilities.rmFile(currentPath);
          }
          cameraItem.canceled();
        }
      }
    }

    QfToolButtonDrawer {
      name: &quot;cameraSettingsDrawer&quot;

      anchors.left: parent.left
      anchors.leftMargin: mainWindow.sceneLeftMargin + 4
      anchors.top: backButton.bottom
      anchors.topMargin: 4

      iconSource: Theme.getThemeVectorIcon(&quot;ic_camera_settings_black_24dp&quot;)
      iconColor: Theme.toolButtonColor
      bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
      spacing: 4
      collapsed: false

      QfToolButton {
        id: cameraSelectionButton

        width: 40
        height: cameraSelectionMenu.count &gt; 1 ? width : 0
        visible: cameraSelectionMenu.count
        padding: 2
        enabled: captureLoader.item

        iconSource: Theme.getThemeVectorIcon(&quot;ic_camera_switch_black_24dp&quot;)
        iconColor: Theme.toolButtonColor
        bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
        round: true

        onClicked: {
          cameraSelectionMenu.popup(cameraSelectionButton.x, cameraSelectionButton.y);
        }
      }

      QfToolButton {
        id: resolutionSelectionButton

        width: 40
        height: resolutionSelectionMenu.count &gt; 1 ? width : 0
        visible: resolutionSelectionMenu.count
        padding: 2
        enabled: captureLoader.item

        iconSource: Theme.getThemeVectorIcon(&quot;ic_camera_resolution_black_24dp&quot;)
        iconColor: Theme.toolButtonColor
        bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
        round: true

        onClicked: {
          resolutionSelectionMenu.popup(resolutionSelectionButton.x, resolutionSelectionButton.y);
        }
      }

      QfToolButton {
        id: stampingButton

        width: 40
        height: 40
        padding: 2

        iconSource: Theme.getThemeVectorIcon(&quot;ic_text_black_24dp&quot;)
        iconColor: cameraSettings.stamping ? Theme.mainColor : Theme.toolButtonColor
        bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
        round: true

        onClicked: {
          cameraSettings.stamping = !cameraSettings.stamping;
          displayToast(cameraSettings.stamping ? qsTr(&quot;Details stamping enabled&quot;) : qsTr(&quot;Details stamping disabled&quot;));
        }
      }

      QfToolButton {
        id: geotagButton

        width: 40
        height: 40
        padding: 2

        iconSource: positionSource.active ? Theme.getThemeVectorIcon(&quot;ic_geotag_white_24dp&quot;) : Theme.getThemeVectorIcon(&quot;ic_geotag_missing_white_24dp&quot;)
        iconColor: cameraSettings.geoTagging ? Theme.mainColor : Theme.toolButtonColor
        bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
        round: true

        onClicked: {
          cameraSettings.geoTagging = !cameraSettings.geoTagging;
          displayToast(cameraSettings.geoTagging ? qsTr(&quot;Geotagging enabled&quot;) : qsTr(&quot;Geotagging disabled&quot;));
        }
      }

      QfToolButton {
        id: gridButton

        width: 40
        height: 40
        padding: 2

        iconSource: Theme.getThemeVectorIcon(&quot;ic_3x3_grid_white_24dp&quot;)
        iconColor: cameraSettings.showGrid ? Theme.mainColor : Theme.toolButtonColor
        bgcolor: Theme.toolButtonBackgroundSemiOpaqueColor
        round: true

        onClicked: {
          cameraSettings.showGrid = !cameraSettings.showGrid;
          displayToast(cameraSettings.showGrid ? qsTr(&quot;Grid enabled&quot;) : qsTr(&quot;Grid disabled&quot;));
        }
      }
    }

    QfMenu {
      id: cameraSelectionMenu

      topMargin: mainWindow.sceneTopMargin
      bottomMargin: mainWindow.sceneBottomMargin
      z: 10000 // 1000s are embedded feature forms, use higher value

      Repeater {
        model: mediaDevices.videoInputs

        delegate: MenuItem {
          property string deviceId: modelData.id
          property bool isDefault: modelData.isDefault

          text: modelData.description + (modelData.position !== CameraDevice.UnspecifiedPosition ? ' (' + (modelData.position === CameraDevice.FrontFace ? qsTr('front') : qsTr('back')) + ')' : '')
          height: 48
          leftPadding: Theme.menuItemCheckLeftPadding
          font: Theme.defaultFont
          enabled: !checked &amp;&amp; captureLoader.item
          checkable: true
          checked: deviceId == cameraSettings.deviceId || (isDefault &amp;&amp; cameraSettings.deviceId == '')
          indicator.height: 20
          indicator.width: 20
          indicator.implicitHeight: 24
          indicator.implicitWidth: 24

          onToggled: {
            if (checked &amp;&amp; cameraSettings.deviceId !== modelData.id) {
              cameraSettings.deviceId = modelData.id;
              if (captureLoader.item) {
                captureLoader.item.camera.cameraDevice = modelData;
                captureLoader.item.camera.applyCameraFormat();
              }
            }
          }
        }
      }
    }

    QfMenu {
      id: resolutionSelectionMenu

      topMargin: mainWindow.sceneTopMargin
      bottomMargin: mainWindow.sceneBottomMargin
      z: 10000 // 1000s are embedded feature forms, use higher value

      function ratioFromResolution(resolution) {
        let smallerValue = Math.min(resolution.width, resolution.height);
        let gdc = 0;
        for (let i = 1; i &lt; smallerValue; i++) {
          if (resolution.width % i === 0 &amp;&amp; resolution.height % i === 0) {
            gdc = i;
          }
        }
        return resolution.width / gdc + ':' + resolution.height / gdc;
      }

      function pixelFormatDescription(pixelFormat) {
        switch (pixelFormat) {
        case 13:
          return 'YUV420P';
        case 14:
          return 'YUV422P';
        case 17:
          return 'YUYV';
        case 29:
          return 'JPEG';
        }
        return '' + pixelFormat;
      }

      Repeater {
        model: captureLoader.item ? captureLoader.item.camera.cameraDevice.videoFormats : []

        delegate: MenuItem {
          property int pixelFormat: modelData.pixelFormat
          property size resolution: modelData.resolution

          text: {
            let details = [];
            let ratio = resolutionSelectionMenu.ratioFromResolution(resolution);
            if (ratio !== '') {
              details.push(ratio);
            }
            let description = resolutionSelectionMenu.pixelFormatDescription(pixelFormat);
            if (description !== '') {
              details.push(description);
            }
            return resolution.width + ' × ' + resolution.height + (details.length &gt; 0 ? ' — ' + details.join(' / ') : '');
          }
          height: 48
          leftPadding: Theme.menuItemCheckLeftPadding
          font: Theme.defaultFont
          enabled: !checked &amp;&amp; captureLoader.item
          checkable: true
          checked: cameraSettings.resolution == resolution &amp;&amp; cameraSettings.pixelFormat == pixelFormat
          indicator.height: 20
          indicator.width: 20
          indicator.implicitHeight: 24
          indicator.implicitWidth: 24

          onToggled: {
            if (checked &amp;&amp; (cameraSettings.resolution != resolution || cameraSettings.pixelFormat != pixelFormat)) {
              cameraSettings.resolution = resolution;
              cameraSettings.pixelFormat = pixelFormat;
              if (captureLoader.item) {
                captureLoader.item.camera.applyCameraFormat();
              }
            }
          }
        }
      }
    }
  }
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 <a href="https://OPENGIS.ch">OPENGIS.ch</a> -  <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC-BY-SA 4.0</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>